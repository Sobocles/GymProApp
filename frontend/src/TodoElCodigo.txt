import { configureStore } from '@reduxjs/toolkit';
import { authSlice } from './Auth/store/index';
import { usersSlice } from './Admin/store/users/usersSlice'; 
import cartReducer from './Store/Store/slices/cartSlice'; 
import carouselReducer from './Store/carouselSlice'; 

export const store = configureStore({
  reducer: {
    users: usersSlice.reducer, 
    auth: authSlice.reducer,
    cart: cartReducer,
    carousel: carouselReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

/// <reference types="vite/client" />
// src/vite.config.ts
export default defineConfig({
    build: {
      rollupOptions: {
        output: {
          manualChunks(id) {
            if (id.includes('node_modules')) {
              return 'vendor';
            }
            if (id.includes('src/Admin')) {
              return 'admin';
            }
            if (id.includes('src/Users')) {
              return 'users';
            }
            if (id.includes('src/Store')) {
              return 'store';
            }
          }
        }
      }
    }
  });

function defineConfig(arg0: { build: { rollupOptions: { output: { manualChunks(id: any): "vendor" | "admin" | "users" | "store" | undefined; }; }; }; }) {
    throw new Error("Function not implemented.");
}


import { Provider } from 'react-redux'
import { BrowserRouter } from 'react-router-dom'
import {AppRouter} from './router/AppRouter';

import { store } from "./store"

function App() {


  return (

    <Provider store={ store }>
        <BrowserRouter>
            <AppRouter />
        </BrowserRouter>
    </Provider>

)
}

export default App

import { createRoot } from 'react-dom/client'
import './index.css'
import GestorGymPro from './GestorGymPro.tsx'

createRoot(document.getElementById('root')!).render(

    <GestorGymPro />

)
import React from 'react';
import { Link } from 'react-router-dom';
import { Box } from '@mui/material';

interface PaginatorProps {
  url: string;
  paginator: {
    number: number;
    totalPages: number;
    first: boolean;
    last: boolean;
  };
  sortBy?: string; // <-- la interrogación indica que es opcional
}


export const Paginator = ({ url, paginator, sortBy }: PaginatorProps) => {

  const order = sortBy || '';

  

  const { number, totalPages, first, last } = paginator;

  
  

  if (totalPages <= 1) return null;

  return (
    <Box
      component="nav"
      sx={{
        position: 'sticky',
        bottom: 0,
        width: '100%',
        backgroundColor: '#fff',
        padding: '10px 0',
        boxShadow: '0 -2px 5px rgba(0,0,0,0.1)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
      }}
    >
      <ul className="pagination" style={{ display: 'flex', listStyle: 'none', padding: 0 }}>
        
        {/* Botón Anterior */}
        {!first && (
          <li className="page-item" style={{ margin: '0 5px' }}>
           <Link to={`${url}/page/${paginator.number - 1}`}>Anterior</Link>
          </li>
        )}

        {/* Números de página */}
        {Array.from(Array(totalPages).keys()).map((pageIndex) => (
          <li
            key={pageIndex}
            className={`page-item ${number === pageIndex ? 'active' : ''}`}
            style={{ margin: '0 5px' }}
          >
            <Link
              className="page-link"
              to={`${url}/page/${pageIndex}${sortBy ? `?sortBy=${sortBy}` : ''}`} >
        
              {pageIndex + 1}
            </Link>
          </li>
        ))}

        {/* Botón Siguiente */}
        {!last && (
          <li className="page-item" style={{ margin: '0 5px' }}>
            <Link to={`${url}/page/${paginator.number + 1}`}>Siguiente</Link>
          </li>
        )}
      </ul>
    </Box>
  );
};
/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import {
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Typography,
  Select,
  MenuItem,
  InputLabel,
  FormControl,
  Button,
} from '@mui/material';
import { Category } from '../../Store/services/CategoryService';

// Esquema de validación
const validationSchema = Yup.object().shape({
  name: Yup.string().required('El nombre es requerido'),
  description: Yup.string()
    .required('La descripción es requerida')
    .max(300, 'La descripción no puede tener más de 200 caracteres'),
  category: Yup.string().required('La categoría es requerida'),
  price: Yup.number().min(0, 'El precio debe ser mayor o igual a 0').required('El precio es requerido'),
  brand: Yup.string().required('La marca es requerida'),
  flavor: Yup.string().required('El sabor es requerido'),
});

// Tipado de las props que recibe
interface ProductFormProps {
  initialValues: any;
  categories: Category[];
  onSubmit: (values: any) => void;
  onClose: () => void; 
}

export const ProductForm: React.FC<ProductFormProps> = ({
  initialValues,
  categories,
  onSubmit,
  onClose,
}) => {
  return (
    <Formik
      initialValues={initialValues}
      enableReinitialize
      validationSchema={validationSchema}
      onSubmit={(values, { resetForm }) => {
        onSubmit(values);
        // Opcional: si quieres limpiar los campos
        resetForm();
      }}
    >
      {({ setFieldValue, handleSubmit }) => (
        // El <Form> engloba el DialogTitle, DialogContent y DialogActions
        <Form onSubmit={handleSubmit}>
          <DialogTitle>
            {initialValues?.name ? 'Editar Producto' : 'Crear Producto'}
          </DialogTitle>

          <DialogContent dividers>
            {/* Nombre */}
            <Field name="name">
              {({ field }: any) => (
                <TextField {...field} label="Nombre" fullWidth margin="normal" />
              )}
            </Field>
            <ErrorMessage name="name" component={Typography} color="error" />

            {/* Descripción */}
            <Field name="description">
              {({ field }: any) => (
                <TextField
                  {...field}
                  label="Descripción"
                  fullWidth
                  margin="normal"
                  multiline
                  rows={3}
                />
              )}
            </Field>
            <ErrorMessage name="description" component={Typography} color="error" />

            {/* Categoría */}
            <Field name="category">
              {({ field }: any) => (
                <FormControl fullWidth margin="normal">
                  <InputLabel id="category-label">Categoría</InputLabel>
                  <Select labelId="category-label" {...field} value={field.value || ''}>
                    <MenuItem value="">
                      <em>Seleccione una categoría</em>
                    </MenuItem>
                    {categories.map((cat) => (
                      <MenuItem key={cat.id} value={cat.name}>
                        {cat.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              )}
            </Field>
            <ErrorMessage name="category" component={Typography} color="error" />

            {/* Marca */}
            <Field name="brand">
              {({ field }: any) => (
                <TextField {...field} label="Marca" fullWidth margin="normal" />
              )}
            </Field>
            <ErrorMessage name="brand" component={Typography} color="error" />

            {/* Sabor */}
            <Field name="flavor">
              {({ field }: any) => (
                <TextField {...field} label="Sabor" fullWidth margin="normal" />
              )}
            </Field>
            <ErrorMessage name="flavor" component={Typography} color="error" />

            {/* Precio */}
            <Field name="price">
              {({ field }: any) => (
                <TextField {...field} label="Precio" type="number" fullWidth margin="normal" />
              )}
            </Field>
            <ErrorMessage name="price" component={Typography} color="error" />

            {/* Stock */}
            <Field name="stock">
              {({ field }: any) => (
                <TextField {...field} label="Stock" type="number" fullWidth margin="normal" />
              )}
            </Field>
            <ErrorMessage name="stock" component={Typography} color="error" />

            {/* Imagen (opcional) */}
            <div style={{ marginTop: '1rem' }}>
              <Typography variant="subtitle1" gutterBottom>
                Imagen (opcional)
              </Typography>
              <input
                type="file"
                onChange={(event) => {
                  if (event.currentTarget.files?.[0]) {
                    setFieldValue('imageFile', event.currentTarget.files[0]);
                  }
                }}
              />
            </div>
          </DialogContent>

          <DialogActions>
            <Button onClick={onClose}>Cancelar</Button>
            <Button type="submit" variant="contained" color="primary">
              {initialValues?.name ? 'Actualizar' : 'Crear'}
            </Button>
          </DialogActions>
        </Form>
      )}
    </Formik>
  );
};
// src/components/ProductCrud/components/ProductList.tsx

import React from 'react';
import {
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  Button,
} from '@mui/material';
import { Product } from '../../Store/interface/Product';
// Importa la función de descuento (ajusta la ruta según corresponda)
import { getDiscountedPrice } from '../../services/DiscountedProductsService';

interface Props {
  products: Product[];
  onEdit: (product: Product) => void;
  onDelete: (id: number) => void;
}

export const ProductList: React.FC<Props> = ({ products, onEdit, onDelete }) => {
  return (
    <Table>
      <TableHead>
      <TableRow>
        <TableCell><strong>ID</strong></TableCell>
        <TableCell><strong>Nombre</strong></TableCell>
        <TableCell><strong>Descripción</strong></TableCell>
        <TableCell><strong>Categoría</strong></TableCell>
        <TableCell><strong>Stock</strong></TableCell> 
 

        <TableCell><strong>Marca</strong></TableCell>
        <TableCell><strong>Sabor</strong></TableCell>
        <TableCell><strong>Imagen</strong></TableCell>
        <TableCell><strong>Precio</strong></TableCell>
   

        <TableCell><strong>Acciones</strong></TableCell>
      </TableRow>
      </TableHead>
      <TableBody>
        {products.map((p) => (
          <TableRow key={p.id}>
            <TableCell>{p.id}</TableCell>
            <TableCell>{p.name}</TableCell>
            <TableCell>{p.description}</TableCell>
            <TableCell>
              {typeof p.category === 'string'
                ? p.category
                : (p.category as any)?.name ?? 'Sin categoría'}
            </TableCell>
            <TableCell>{p.stock}</TableCell>
            <TableCell>{p.brand || 'Sin marca'}</TableCell>
            <TableCell>{p.flavor || 'Sin sabor'}</TableCell>
            <TableCell>
              {p.imageUrl ? (
                <img src={p.imageUrl} alt={p.name} width="50" />
              ) : (
                'Sin imagen'
              )}
            </TableCell>
            <TableCell>
              {(() => {
                // Calcula el precio con descuento para el producto
                const { originalPrice, finalPrice, isDiscountActive, discountReason } = getDiscountedPrice(p);

                return isDiscountActive ? (
                  <>
                    <span style={{ textDecoration: 'line-through' }}>
                      ${originalPrice.toFixed(2)}
                    </span>{' '}
                    <strong style={{ color: 'red' }}>
                      ${finalPrice.toFixed(2)}
                    </strong>
                    {discountReason && (
                      <i style={{ color: 'red', marginLeft: 5 }}>
                        {discountReason}
                      </i>
                    )}
                  </>
                ) : (
                  <>${originalPrice.toFixed(2)}</>
                );
              })()}
            </TableCell>
            <TableCell>
              <Button
                variant="outlined"
                color="primary"
                onClick={() => onEdit(p)}
                sx={{ mr: 1, mb: 1, width: '120px' }} 
                
              >
                Editar
              </Button>
              <Button
                variant="outlined"
                color="error"
                onClick={() => onDelete(p.id!)}
                sx={{ width: '120px' }} 
              >
                Eliminar
              </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
};
/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogActions,
  DialogContent,
  Button,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
} from '@mui/material';

import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// Interfaces
import { Product } from '../../Store/interface/Product';
import { Category } from '../../Store/services/CategoryService';

// Interfaz de Props
interface ProductModalFormProps {
  open: boolean;
  onClose: () => void;
  productSelected: Product | null;
  categories: Category[];
  onCreate: (formData: FormData) => void;
  onUpdate: (id: number, formData: FormData) => void;
}

// Esquema de validación con Yup
const validationSchema = Yup.object().shape({
  name: Yup.string().required('El nombre es requerido'),
  description: Yup.string()
    .required('La descripción es requerida')
    .max(200, 'La descripción no puede tener más de 200 caracteres'),
  category: Yup.string().required('La categoría es requerida'),
  price: Yup.number()
    .min(0, 'El precio debe ser mayor o igual a 0')
    .required('El precio es requerido'),
  brand: Yup.string().required('La marca es requerida'),
  flavor: Yup.string().required('El sabor es requerido'),
  stock: Yup.number()
  .min(0, 'El stock debe ser mayor o igual a 0')
  .required('El stock es requerido'),
});

export const ProductModalForm: React.FC<ProductModalFormProps> = ({
  open,
  onClose,
  productSelected,
  categories,
  onCreate,
  onUpdate,
}) => {
  
  // Valores iniciales para Formik
  const initialValues = {
    name: productSelected?.name || '',
    description: productSelected?.description || '',
    category: typeof productSelected?.category === 'string'
                ? productSelected?.category
                : (productSelected?.category as any)?.name || '',
    price: productSelected?.price || 0,
    stock: productSelected?.stock || 0,
    brand: productSelected?.brand || '',
    flavor: productSelected?.flavor || '',
    discountPercent: productSelected?.discountPercent || '',
    discountReason: productSelected?.discountReason || '',
    discountStart: productSelected?.discountStart || '',
    discountEnd: productSelected?.discountEnd || '',
    imageFile: null,
  };
  // Al enviar el formulario
  const handleSubmitFormik = async (values: typeof initialValues) => {
    const formData = new FormData();
    formData.append('name', values.name);
    formData.append('description', values.description);
    formData.append('category', values.category);
    formData.append('price', values.price.toString());
    formData.append('stock', values.stock.toString());
    formData.append('brand', values.brand);
    formData.append('flavor', values.flavor);
    formData.append('discountPercent', values.discountPercent?.toString() || '');
    formData.append('discountReason', values.discountReason || '');
    formData.append('discountStart', values.discountStart || '');
    formData.append('discountEnd', values.discountEnd || '');
  
    if (values.imageFile) {
      formData.append('image', values.imageFile);
    }
  
    if (productSelected) {
      await onUpdate(productSelected.id!, formData);
    } else {
      await onCreate(formData);
    }
    onClose();
  };
  

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
      {/* Formik envuelve el Dialog entero */}
      <Formik
        initialValues={initialValues}
        enableReinitialize
        validationSchema={validationSchema}
        onSubmit={handleSubmitFormik}
      >
        {({ setFieldValue, handleSubmit }) => (
          // Notar que aquí `<Form>` engloba TANTO <DialogContent> COMO <DialogActions>
          <Form onSubmit={handleSubmit}>
            <DialogTitle>
              {productSelected ? 'Editar Producto' : 'Crear Producto'}
            </DialogTitle>

            <DialogContent dividers>
              {/* Campo: name */}
              <Field name="name">
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Nombre"
                    fullWidth
                    margin="normal"
                  />
                )}
              </Field>
              <ErrorMessage name="name">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: description */}
              <Field name="description">
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Descripción"
                    fullWidth
                    margin="normal"
                    multiline
                    rows={3}
                  />
                )}
              </Field>
              <ErrorMessage name="description">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: category */}
              <Field name="category">
                {({ field }: any) => (
                  <FormControl fullWidth margin="normal">
                    <InputLabel id="select-category-label">Categoría</InputLabel>
                    <Select
                      labelId="select-category-label"
                      {...field}
                      value={field.value || ''}
                    >
                      <MenuItem value="">
                        <em>Seleccione una categoría</em>
                      </MenuItem>
                      {categories.map((cat) => (
                        <MenuItem key={cat.id} value={cat.name}>
                          {cat.name}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                )}
              </Field>
              <ErrorMessage name="category">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: brand */}
              <Field name="brand">
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Marca"
                    fullWidth
                    margin="normal"
                  />
                )}
              </Field>
              <ErrorMessage name="brand">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: flavor */}
              <Field name="flavor">
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Sabor"
                    fullWidth
                    margin="normal"
                  />
                )}
              </Field>
              <ErrorMessage name="flavor">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: price */}
              <Field name="price">
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Precio"
                    type="number"
                    fullWidth
                    margin="normal"
                  />
                )}
              </Field>
              <ErrorMessage name="price">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>
              <Field name="discountPercent">
            {({ field }: any) => (
              <TextField
                {...field}
                label="Descuento (%)"
                type="number"
                fullWidth
                margin="normal"
              />
            )}
          </Field>

          <Field name="discountReason">
            {({ field }: any) => (
              <TextField
                {...field}
                label="Razón de la Oferta"
                fullWidth
                margin="normal"
              />
            )}
          </Field>

          <Field name="discountStart">
            {({ field }: any) => (
              <TextField
                {...field}
                label="Inicio de Oferta"
                type="datetime-local"
                fullWidth
                margin="normal"
                InputLabelProps={{ shrink: true }} // Para mostrar la etiqueta arriba
              />
            )}
          </Field>

          <Field name="discountEnd">
            {({ field }: any) => (
              <TextField
                {...field}
                label="Fin de Oferta"
                type="datetime-local"
                fullWidth
                margin="normal"
                InputLabelProps={{ shrink: true }}
              />
            )}
          </Field>



              {/* Campo: stock */}
              <Field name="stock">
       
                {({ field }: any) => (
                  <TextField
                    {...field}
                    label="Stock"
                    type="number"
                    fullWidth
                    margin="normal"
                  />
                )}
              </Field>
              <ErrorMessage name="stock">
                {(msg) => <Typography color="error">{msg}</Typography>}
              </ErrorMessage>

              {/* Campo: imagen (opcional) */}
              <div style={{ marginTop: '1rem' }}>
                <Typography variant="subtitle1" gutterBottom>
                  Imagen (opcional)
                </Typography>
                <input
                  type="file"
                  onChange={(event) => {
                    if (event.currentTarget.files?.[0]) {
                      setFieldValue('imageFile', event.currentTarget.files[0]);
                    }
                  }}
                />
              </div>
            </DialogContent>

            {/* Botones dentro del mismo <Form> */}
            <DialogActions>
              <Button onClick={onClose}>Cancelar</Button>
              <Button type="submit" variant="contained" color="primary">
                {productSelected ? 'Actualizar' : 'Crear'}
              </Button>
            </DialogActions>
          </Form>
        )}
      </Formik>
    </Dialog>
  );
};
// src/Admin/components/UseForm.tsx

import { useFormik } from 'formik';
import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import { TextField, Button, Checkbox, FormControlLabel, Box, Typography } from '@mui/material';
import * as Yup from 'yup';
import { useState } from 'react';

interface UserFormProps {
  userSelected: UserInterface;
  handlerAddUser: (user: UserInterface) => void;
  handlerCloseForm: () => void;
}

export const UserForm = ({ userSelected, handlerAddUser, handlerCloseForm }: UserFormProps) => {
  const [isTrainer, setIsTrainer] = useState(userSelected.trainer || false);

  // Definir el esquema de validación usando Yup
  const validationSchema = Yup.object({
    username: Yup.string()
      .required('El nombre de usuario es obligatorio'),
    email: Yup.string()
      .email('Debe ser un email válido')
      .required('El email es obligatorio'),
    admin: Yup.boolean(),
    trainer: Yup.boolean(),
    // Campos adicionales para Trainer
    specialization: isTrainer ? Yup.string().required('Especialización es requerida') : Yup.string(),
    experienceYears: isTrainer ? Yup.number().required('Años de experiencia son requeridos') : Yup.number(),
    availability: isTrainer ? Yup.boolean().required('Disponibilidad es requerida') : Yup.boolean(),
    monthlyFee: isTrainer ? Yup.number().required('Cuota mensual es requerida') : Yup.number(),
    title: isTrainer ? Yup.string().required('Título es requerido') : Yup.string(),
    studies: isTrainer ? Yup.string().required('Estudios son requeridos') : Yup.string(),
    certifications: isTrainer ? Yup.string().required('Certificaciones son requeridas') : Yup.string(),
    description: isTrainer ? Yup.string().required('Descripción es requerida') : Yup.string(),
    instagramUrl: Yup.string().notRequired(),
    whatsappNumber: Yup.string().notRequired()
  });

  const formik = useFormik({
    initialValues: {
      id: userSelected?.id || '',
      username: userSelected?.username || '',
      email: userSelected?.email || '',
      password: '',
      admin: userSelected?.admin || false,
      trainer: userSelected?.trainer || false,
      specialization: '',
      experienceYears: '',
      availability: false,
      monthlyFee: '',
      title: '',
      studies: '',
      certifications: '',
      description: '',
      instagramUrl: '',
      whatsappNumber: '',
      certificationFile: undefined,
    },
    validationSchema: validationSchema,
    onSubmit: (values) => {
      handlerAddUser(values);
    },
  });
  

  const handleTrainerCheckbox = (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsTrainer(e.target.checked);
    formik.handleChange(e);
  };

  return (
    <Box component="form" onSubmit={formik.handleSubmit} noValidate sx={{ overflowY: 'auto' }}>
      <TextField
        fullWidth
        margin="normal"
        label="Nombre de Usuario"
        name="username"
        value={formik.values.username}
        onChange={formik.handleChange}
        error={formik.touched.username && Boolean(formik.errors.username)}
        helperText={formik.touched.username && formik.errors.username}
      />



      <TextField
        fullWidth
        margin="normal"
        label="Email"
        name="email"
        value={formik.values.email}
        onChange={formik.handleChange}
        error={formik.touched.email && Boolean(formik.errors.email)}
        helperText={formik.touched.email && formik.errors.email}
      />

      <FormControlLabel
        control={
          <Checkbox
            checked={formik.values.admin}
            onChange={formik.handleChange}
            name="admin"
            color="primary"
          />
        }
        label="Admin"
      />

      <FormControlLabel
        control={
          <Checkbox
            checked={formik.values.trainer}
            onChange={handleTrainerCheckbox}
            name="trainer"
            color="primary"
          />
        }
        label="Entrenador"
      />

      {/* Mostrar campos adicionales si es Trainer */}
      {isTrainer && (
        <>
          <Typography variant="h6" sx={{ mt: 2 }}>Información del Entrenador</Typography>
          <TextField
            fullWidth
            margin="normal"
            label="Especialización"
            name="specialization"
            value={formik.values.specialization}
            onChange={formik.handleChange}
            error={formik.touched.specialization && Boolean(formik.errors.specialization)}
            helperText={formik.touched.specialization && formik.errors.specialization}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Años de Experiencia"
            name="experienceYears"
            type="number"
            value={formik.values.experienceYears}
            onChange={formik.handleChange}
            error={formik.touched.experienceYears && Boolean(formik.errors.experienceYears)}
            helperText={formik.touched.experienceYears && formik.errors.experienceYears}
          />
          <FormControlLabel
            control={
              <Checkbox
                checked={formik.values.availability}
                onChange={formik.handleChange}
                name="availability"
                color="primary"
              />
            }
            label="Disponible"
          />
          <TextField
            fullWidth
            margin="normal"
            label="Cuota Mensual"
            name="monthlyFee"
            type="number"
            value={formik.values.monthlyFee}
            onChange={formik.handleChange}
            error={formik.touched.monthlyFee && Boolean(formik.errors.monthlyFee)}
            helperText={formik.touched.monthlyFee && formik.errors.monthlyFee}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Título"
            name="title"
            value={formik.values.title}
            onChange={formik.handleChange}
            error={formik.touched.title && Boolean(formik.errors.title)}
            helperText={formik.touched.title && formik.errors.title}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Estudios"
            name="studies"
            value={formik.values.studies}
            onChange={formik.handleChange}
            error={formik.touched.studies && Boolean(formik.errors.studies)}
            helperText={formik.touched.studies && formik.errors.studies}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Certificaciones"
            name="certifications"
            value={formik.values.certifications}
            onChange={formik.handleChange}
            error={formik.touched.certifications && Boolean(formik.errors.certifications)}
            helperText={formik.touched.certifications && formik.errors.certifications}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Descripción"
            name="description"
            multiline
            rows={4}
            value={formik.values.description}
            onChange={formik.handleChange}
            error={formik.touched.description && Boolean(formik.errors.description)}
            helperText={formik.touched.description && formik.errors.description}
          />
<TextField
  fullWidth
  margin="normal"
  label="Instagram (opcional)"
  name="instagramUrl" // <--- sin "trainerDetails."
  value={formik.values.instagramUrl}
  onChange={formik.handleChange}
/>
<TextField
  fullWidth
  margin="normal"
  label="WhatsApp (opcional)"
  name="whatsappNumber"
  value={formik.values.whatsappNumber}
  onChange={formik.handleChange}
/>
<Typography variant="subtitle1" sx={{ mt: 2 }}>
      Certificación (PDF / imagen)
    </Typography>
    <input
      type="file"
      name="certificationFile"
      onChange={(e) => {
        if (e.currentTarget.files && e.currentTarget.files.length > 0) {
          formik.setFieldValue('certificationFile', e.currentTarget.files[0]);
        }
      }}
    />

        </>
      )}

      <Box sx={{ mt: 2 }}>
        <Button variant="contained" color="primary" type="submit">
          {formik.values.id ? 'Editar' : 'Crear'}
        </Button>
        <Button
          variant="outlined"
          color="secondary"
          onClick={handlerCloseForm}
          sx={{ ml: 2 }}
        >
          Cerrar
        </Button>
      </Box>
    </Box>
  );
};
import React from 'react';
import { useUsers } from '../hooks/useUsers';
import { UserForm } from './UseForm';
import { Modal, Box, Typography, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

export const UserModalForm = () => {
  const { userSelected, visibleForm, handlerCloseForm, handlerAddUser } = useUsers();

  const validUserSelected = userSelected || {
    id: '',
    username: '',
    email: '',
    password: '',
    admin: false,
    trainer: false,
    role: '',
    roles: []
  };

  const style = {
    position: 'absolute' as const,
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    width: '90%', // Ajustar el ancho para pantallas más pequeñas
    maxWidth: 600, // Ancho máximo del modal
    bgcolor: 'background.paper',
    boxShadow: 24,
    p: 4,
    overflowY: 'auto', // Habilitar desplazamiento vertical
    maxHeight: '80vh', // Altura máxima relativa a la ventana
  };

  return (
    <Modal
      open={visibleForm}
      onClose={handlerCloseForm}
      aria-labelledby="modal-title"
      aria-describedby="modal-description"
    >
      <Box sx={style}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography id="modal-title" variant="h6" component="h2">
            {validUserSelected.id ? 'Editar' : 'Crear'} Usuario
          </Typography>
          <IconButton aria-label="close" onClick={handlerCloseForm}>
            <CloseIcon />
          </IconButton>
        </Box>
        <Box id="modal-description" sx={{ mt: 2 }}>
          <UserForm
            userSelected={validUserSelected} // Pasar un valor válido
            handlerAddUser={handlerAddUser}
            handlerCloseForm={handlerCloseForm}
          />
        </Box>
      </Box>
    </Modal>
  );
};
// src/Admin/components/UserRow.tsx
import { useUsers } from "../hooks/useUsers";
import { useAuth } from "../../Auth/hooks/useAuth";
import { UserInterface } from '../../Auth/Interfaces/UserInterface';

import { TableRow, TableCell, Button, Avatar } from '@mui/material';
import { Link as RouterLink } from "react-router-dom";

export const UserRow = ({ id, username, email, admin, profileImageUrl }: UserInterface) => {

    const { handlerUserSelectedForm, handlerRemoveUser } = useUsers();
    const { login } = useAuth();

    return (
        <TableRow>
              <TableCell>
                <Avatar 
                alt={username} 
                src={profileImageUrl} 
                sx={{ width: 60, height: 60 }}
                />
            </TableCell>
            <TableCell>{id}</TableCell>
            <TableCell>{username}</TableCell>
            <TableCell>{email}</TableCell>

            {login.isAdmin && (
                <>
                    <TableCell>
                        <Button
                            variant="contained"
                            color="secondary"
                            size="small"
                            onClick={() => handlerUserSelectedForm({
                                id,
                                username,
                                email,
                                admin,
                                profileImageUrl
                            })}
                        >
                            Update
                        </Button>
                    </TableCell>
                    <TableCell>
                        <Button
                            variant="contained"
                            color="secondary"
                            size="small"
                            component={RouterLink}
                            to={'/users/edit/' + id}
                        >
                            Update Route
                        </Button>
                    </TableCell>
                    <TableCell>
                        <Button
                            variant="contained"
                            color="error"
                            size="small"
                            onClick={() => id && handlerRemoveUser(id)}
                        >
                            Remove
                        </Button>
                    </TableCell>
                </>
            )}
        </TableRow>
    );
};
import React from 'react';
import { UserRow } from "./userRow";
import { useUsers } from "../hooks/useUsers";
import { useAuth } from "../../Auth/hooks/useAuth";
import {
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from '@mui/material';

export const UsersList = () => {
  const { users } = useUsers();
  const { login } = useAuth();

  return (
    <Table>
      <TableHead>
        <TableRow>
        <TableCell>Imagen</TableCell>
          <TableCell>#</TableCell>
          <TableCell>Username</TableCell>
          <TableCell>Email</TableCell>
          {login.isAdmin && (
            <>
              <TableCell>Update</TableCell>
              <TableCell>Remove</TableCell>
            </>
          )}
        </TableRow>
      </TableHead>
      <TableBody>
        {users.map((user) => (
          <UserRow
            
            key={user.id}
            profileImageUrl={user.profileImageUrl}
            id={user.id}
            username={user.username}
            email={user.email}
            admin={user.admin} trainer={false} roles={[]}          />
        ))}
      </TableBody>
    </Table>
  );
};
import React, { useEffect, useState } from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import Swal from 'sweetalert2'; // Importación de SweetAlert2
import apiClient from '../../../Apis/apiConfig';
import {
  Box,
  Button,
  TextField,
  MenuItem,
  Typography,
  CircularProgress,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { TimePicker } from '@mui/x-date-pickers/TimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format } from 'date-fns';

interface PersonalTrainerDto {
  id: number;
  username: string;
  email: string;
}

interface TrainerAvailabilityRequest {
  day: string;       // "YYYY-MM-DD"
  startTime: string; // "HH:mm"
  endTime: string;   // "HH:mm"
}

const AdminTrainerAvailabilityForm: React.FC = () => {
  const [trainers, setTrainers] = useState<PersonalTrainerDto[]>([]);
  const [loadingTrainers, setLoadingTrainers] = useState(true);

  useEffect(() => {
    const fetchTrainers = async () => {
      try {
        const response = await apiClient.get('/trainer-schedule/all-available');
        setTrainers(response.data);
      } catch (error: any) {
        Swal.fire('Error', 'Error al cargar entrenadores disponibles', 'error');
      } finally {
        setLoadingTrainers(false);
      }
    };
    fetchTrainers();
  }, []);

  const validationSchema = Yup.object({
    trainerId: Yup.number().required('Selecciona un entrenador'),
    day: Yup.date().required('Selecciona un día'),
    startTime: Yup.date().required('Selecciona la hora de inicio'),
    endTime: Yup.date()
      .required('Selecciona la hora de fin')
      .test(
        'is-after-start',
        'La hora de fin debe ser posterior a la hora de inicio',
        function (value) {
          const { startTime } = this.parent;
          return value && startTime && value > startTime;
        }
      ),
  });

  const formik = useFormik({
    initialValues: {
      trainerId: '',
      day: null as Date | null,
      startTime: null as Date | null,
      endTime: null as Date | null,
    },
    validationSchema,
    onSubmit: async (values) => {
      try {
        const dayStr = values.day ? format(values.day, 'yyyy-MM-dd') : '';
        const startTimeStr = values.startTime
          ? format(values.startTime, 'HH:mm')
          : '';
        const endTimeStr = values.endTime
          ? format(values.endTime, 'HH:mm')
          : '';

        const requestBody: TrainerAvailabilityRequest = {
          day: dayStr,
          startTime: startTimeStr,
          endTime: endTimeStr,
        };

        await apiClient.post(
          `/trainer-schedule/${values.trainerId}/availability`,
          requestBody
        );

        Swal.fire(
          'Éxito',
          'Disponibilidad creada con éxito',
          'success'
        );
        formik.resetForm();
      } catch (error: any) {
        Swal.fire(
          'Error',
          error.response?.data || 'Error al crear la disponibilidad',
          'error'
        );
      }
    },
  });

  if (loadingTrainers) {
    return <CircularProgress />;
  }

  return (
    <Box sx={{ maxWidth: 400, margin: '0 auto', mt: 4 }}>
      <Typography variant="h5" gutterBottom>
        Crear Disponibilidad para Entrenador
      </Typography>
      <form onSubmit={formik.handleSubmit}>
        <TextField
          select
          fullWidth
          margin="normal"
          label="Entrenador"
          name="trainerId"
          value={formik.values.trainerId}
          onChange={formik.handleChange}
          error={formik.touched.trainerId && Boolean(formik.errors.trainerId)}
          helperText={formik.touched.trainerId && formik.errors.trainerId}
        >
          <MenuItem value="">Seleccione un entrenador</MenuItem>
          {trainers.map((trainer) => (
            <MenuItem key={trainer.id} value={trainer.id}>
              {trainer.username} ({trainer.email})
            </MenuItem>
          ))}
        </TextField>

        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DatePicker
            label="Día"
            value={formik.values.day}
            onChange={(value: Date | null) =>
              formik.setFieldValue('day', value)
            }
            renderInput={(params) => (
              <TextField
                {...params}
                fullWidth
                margin="normal"
                error={formik.touched.day && Boolean(formik.errors.day)}
                helperText={formik.touched.day && formik.errors.day}
              />
            )}
          />

          <TimePicker
            label="Hora inicio"
            value={formik.values.startTime}
            onChange={(value: Date | null) =>
              formik.setFieldValue('startTime', value)
            }
            renderInput={(params) => (
              <TextField
                {...params}
                fullWidth
                margin="normal"
                error={
                  formik.touched.startTime && Boolean(formik.errors.startTime)
                }
                helperText={formik.touched.startTime && formik.errors.startTime}
              />
            )}
          />

          <TimePicker
            label="Hora fin"
            value={formik.values.endTime}
            onChange={(value: Date | null) =>
              formik.setFieldValue('endTime', value)
            }
            renderInput={(params) => (
              <TextField
                {...params}
                fullWidth
                margin="normal"
                error={formik.touched.endTime && Boolean(formik.errors.endTime)}
                helperText={formik.touched.endTime && formik.errors.endTime}
              />
            )}
          />
        </LocalizationProvider>

        <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
          <Button variant="contained" color="primary" type="submit">
            Guardar
          </Button>
        </Box>
      </form>
    </Box>
  );
};

export default AdminTrainerAvailabilityForm;
// src/Admin/hooks/useFacturas.ts
import { useState, useEffect } from "react";
import { FacturasPage, getFacturasPage } from "../services/facturaService";
import { PaymentProductDTO } from "../../Store/interface/Payment";

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const useFacturas = (currentPage: number, searchTerm: string) => {
  const [facturas, setFacturas] = useState<PaymentProductDTO[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchFacturasPage = async (page: number, search: string) => {
    try {
      setIsLoading(true);
      setError(null);

      // Ahora se pasa el parámetro "search" a la función del servicio
      const response = await getFacturasPage(page, 6, search);
      console.log("aqui la informacion de la factura",response);
      const data: FacturasPage = response.data;
      setFacturas(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (err: any) {
      console.error(err);
      setError("Error al obtener las facturas de productos aprobados.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchFacturasPage(currentPage, searchTerm);
  }, [currentPage, searchTerm]);

  return {
    facturas,
    paginator,
    isLoading,
    error,
    reloadFacturas: fetchFacturasPage, // Por si necesitas recargar manualmente
  };
};
import { useEffect, useState } from 'react';
import { getTotalRevenue, getAdminDashboardRevenue, AdminDashboardRevenue } from '../services/FinancialService';

export const useFinancialData = () => {
  const [totalRevenue, setTotalRevenue] = useState<number | null>(null);
  const [adminRevenueData, setAdminRevenueData] = useState<AdminDashboardRevenue | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [total, adminData] = await Promise.all([
          getTotalRevenue(),
          getAdminDashboardRevenue()
        ]);

        setTotalRevenue(total);
        setAdminRevenueData(adminData);
      } catch (err: any) {
        console.error('Error fetching financial data:', err);
        setError('Error fetching financial data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  return {
    totalRevenue,
    adminRevenueData,
    loading,
    error
  };
};
// src/hooks/useGroupClasses.ts
import { useState } from 'react';
import { createGroupClass, assignTrainerToClass, CreateGroupClassData } from '../services/groupClassService';

export const useGroupClasses = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreateClass = async (data: CreateGroupClassData) => {
    try {
      setLoading(true);
      setError(null);
      const result = await createGroupClass(data);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error al crear la clase grupal');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const handleAssignTrainer = async (classId: number, trainerId: number) => {
    try {
      setLoading(true);
      setError(null);
      const result = await assignTrainerToClass(classId, trainerId);
      return result;
    } catch (err: any) {
      setError(err.message || 'Error al asignar entrenador');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    loading,
    error,
    handleCreateClass,
    handleAssignTrainer
  };
};
/* eslint-disable @typescript-eslint/no-explicit-any */
// src/Admin/hooks/usePlanes.ts
import { useState, useEffect } from "react";
import {  PlanesPage, getPlanesPage } from "../services/facturaService";
import { PaymentPlanDTO } from "../../Store/interface/Payment";

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const usePlanes = (currentPage: number, searchTerm: string) => {
  const [planes, setPlanes] = useState<PaymentPlanDTO[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchPlanesPage = async (page: number, search: string) => {
    try {
      setIsLoading(true);
      setError(null);


      const response = await getPlanesPage(page, 6, search);
      const data: PlanesPage = response.data;
      setPlanes(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (err: any) {
      console.error(err);
      setError("Error al obtener los pagos aprobados de planes.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchPlanesPage(currentPage, searchTerm);
  }, [currentPage, searchTerm]);

  return {
    planes,
    paginator,
    isLoading,
    error,
    reloadPlanes: fetchPlanesPage, 
  };
};
// src/components/ProductCrud/hooks/useProductCrud.ts

import { useState, useEffect } from 'react';
import Swal from 'sweetalert2';
import {
  getAllProducts,
  getProductsPage,
  createProduct,
  updateProduct,
  deleteProduct,
  getAllCategories
} from '../../Store/services/ProductService';

import { Product } from '../../Store/interface/Product';

interface Category {
  id: number;
  name: string;
}

interface PaginatorState {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

export const useProductCrud = (currentPage: number, searchTerm: string) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    number: 0,
    totalPages: 1,
    first: true,
    last: false,
  });
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [openDialog, setOpenDialog] = useState(false);

  // Cargar categorías e inicial (similar a fetchAllAndFilter / fetchProductsPage)
  useEffect(() => {
    if (searchTerm.trim() === '') {
      fetchProductsPage();
      fetchCategories();
    } else {
      fetchAllAndFilter();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentPage, searchTerm]);

  // Obtener productos paginados
  const fetchProductsPage = async () => {
    try {
      const data = await getProductsPage(currentPage, 6);
    
      setProducts(data.content);
      setPaginator({
        number: data.number,
        totalPages: data.totalPages,
        first: data.first,
        last: data.last,
      });
    } catch (error) {
      console.error('Error al obtener productos paginados:', error);
    }
  };

  // Obtener *todos* y filtrar en front
  const fetchAllAndFilter = async () => {
    try {
      const all = await getAllProducts();
      const filtered = all.filter((p) =>
        p.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setProducts(filtered);
      setPaginator({
        number: 0,
        totalPages: 1,
        first: true,
        last: true,
      });
    } catch (error) {
      console.error('Error al obtener productos:', error);
    }
  };

  // Obtener categorías
  const fetchCategories = async () => {
    try {
      const categoriesData = await getAllCategories();
      setCategories(categoriesData);
    } catch (error) {
      console.error('Error al obtener categorías:', error);
    }
  };

  // Crear producto
  const handlerCreateProduct = async (formData: FormData) => {
    try {
      await createProduct(formData);
      Swal.fire('Producto creado', 'El producto ha sido creado con éxito.', 'success');
      await fetchProductsPage();
    } catch (error) {
      console.error('Error al crear producto:', error);
      Swal.fire('Error', 'Ocurrió un error al guardar el producto.', 'error');
    }
  };

  // Editar producto
  const handlerUpdateProduct = async (id: number, formData: FormData) => {
    console.log("aqui la form data",formData);
    try {
      await updateProduct(id, formData);
      Swal.fire('Producto actualizado', 'El producto ha sido actualizado con éxito.', 'success');
      await fetchProductsPage();
    } catch (error) {
      console.error('Error al actualizar producto:', error);
      Swal.fire('Error', 'Ocurrió un error al guardar el producto.', 'error');
    }
  };

  // Eliminar producto
  const handlerDeleteProduct = async (productId: number) => {
    try {
      await deleteProduct(productId);
      await fetchProductsPage();
      Swal.fire('Producto eliminado', 'El producto ha sido eliminado con éxito.', 'success');
    } catch (error) {
      console.error('Error al eliminar producto:', error);
      Swal.fire('Error', 'Ocurrió un error al eliminar el producto.', 'error');
    }
  };

  // Mostrar el modal en modo "Crear"
  const handleOpenCreate = () => {
    setSelectedProduct(null);
    setOpenDialog(true);
  };

  // Mostrar el modal en modo "Editar"
  const handleEdit = (product: Product) => {
    setSelectedProduct(product);
    setOpenDialog(true);
  };

  // Cerrar modal
  const handleCloseDialog = () => {
    setSelectedProduct(null);
    setOpenDialog(false);
  };

  return {
    products,
    paginator,
    categories,
    selectedProduct,
    openDialog,

    // funciones
    handlerCreateProduct,
    handlerUpdateProduct,
    handlerDeleteProduct,
    handleOpenCreate,
    handleEdit,
    handleCloseDialog,
  };
};
/* eslint-disable @typescript-eslint/no-explicit-any */
// src/Admin/hooks/useUsers.ts

import { useDispatch, useSelector } from 'react-redux';
import { addUser, removeUser,  loadingUsers, onUserSelectedForm, onOpenForm, onCloseForm, loadingError, updatePaginator } from '../../Admin/store/users/usersSlice';
import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import * as userService from '../../Admin/services/UserService';
import { useState } from 'react';
import apiClient from '../../Apis/apiConfig';

export const useUsers = () => {
  const dispatch = useDispatch();
  const { users, paginator, visibleForm,  errors, isLoading } = useSelector((state: any) => state.users);
  const [searchTerm, setSearchTerm] = useState('');

  const getUsers = async (page: number) => {
    try {
      const response = await userService.findAllPages(page, searchTerm);
      dispatch(loadingUsers(response.data.content));
      dispatch(updatePaginator({
        number: response.data.number,
        totalPages: response.data.totalPages,
        first: response.data.first,
        last: response.data.last,
      }));
    } catch (error) {
      console.error(error);
      dispatch(loadingError({ errorMessage: 'Error al cargar usuarios' }));
    }
  };

  const handlerOpenForm = () => {
    dispatch(onOpenForm());
  };

  const handlerCloseForm = () => {
    dispatch(onCloseForm());
  };

  const handlerUserSelectedForm = (user: UserInterface) => {
    dispatch(onUserSelectedForm(user));
  };

  const handlerAddUser = async (user: UserInterface) => {
    try {
      // Crear el usuario
      const response = await userService.save(user);
      const createdUser = response.data;
      console.log("usuario creado",createdUser)

      dispatch(addUser(createdUser));

      // Si el usuario es un trainer, asignar el rol de trainer y crear PersonalTrainer
      if (user.trainer) {
        console.log(user.trainer);
        const trainerData = {
          specialization: (user as any).specialization,
          experienceYears: (user as any).experienceYears,
          availability: (user as any).availability,
          monthlyFee: (user as any).monthlyFee,
          title: (user as any).title,
          studies: (user as any).studies,
          certifications: (user as any).certifications,
          description: (user as any).description,
          instagramUrl: (user as any).instagramUrl,     
          whatsappNumber: (user as any).whatsappNumber

        };
        console.log("trainerData",trainerData);
        const formData = new FormData();


        formData.append('specialization', trainerData.specialization);
        formData.append('experienceYears', String(trainerData.experienceYears));
        formData.append('availability', String(trainerData.availability));
        formData.append('monthlyFee', String(trainerData.monthlyFee));
        formData.append('title', trainerData.title);
        formData.append('studies', trainerData.studies);
        formData.append('certifications', trainerData.certifications);
        formData.append('description', trainerData.description);
        
        if (trainerData.instagramUrl) {
          formData.append('instagramUrl', trainerData.instagramUrl);
        }
        if (trainerData.whatsappNumber) {
          formData.append('whatsappNumber', trainerData.whatsappNumber);
        }
        
        // Y si hay un archivo
        if (user.certificationFile) {
          formData.append('certificationFile', user.certificationFile);
        }
  
        // Si se subió archivo, lo añadimos:
        if (user.certificationFile) {
          formData.append('certificationFile', user.certificationFile);
        }
  
        // Llamamos a /trainers/{createdUser.id}/assign
        const response = await apiClient.post(
          `/trainers/${createdUser.id}/assign`,
          formData,
          {
            headers: { 'Content-Type': 'multipart/form-data' },
          }
        );
        
        console.log(response);
      }

    } catch (error: any) {
      console.error(error);
      if (error.response && error.response.data) {
        dispatch(loadingError({ errorMessage: error.response.data.message || 'Error al crear usuario' }));
      } else {
        dispatch(loadingError({ errorMessage: 'Error al crear usuario' }));
      }
    }
  };

  const handlerRemoveUser = async (id: string) => {
    try {
      await userService.remove(id);
      dispatch(removeUser(id));
    } catch (error) {
      console.error(error);
      dispatch(loadingError({ errorMessage: 'Error al eliminar usuario' }));
    }
  };

  return {
    users,
    visibleForm,
    handlerOpenForm,
    handlerCloseForm,
    handlerUserSelectedForm,
    handlerAddUser,
    handlerRemoveUser,
    paginator,
    searchTerm,
    setSearchTerm,
    getUsers,
    errors,
    isLoading,
  };
};
// src/Admin/pages/GroupClassesAssignTrainerPage.tsx
import React from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import { TextField, Button, Box, Typography, Container } from '@mui/material';
import { useGroupClasses } from '../../Admin/hooks/useGroupClasses';

const validationSchema = Yup.object({
  classId: Yup.number().required('El ID de la clase es requerido'),
  trainerId: Yup.number().required('El ID del entrenador es requerido'),
});

export const GroupClassesAssignTrainerPage: React.FC = () => {
  const { handleAssignTrainer, loading, error } = useGroupClasses();

  const formik = useFormik({
    initialValues: {
      classId: 0,
      trainerId: 0,
    },
    validationSchema: validationSchema,
    onSubmit: async (values) => {
      try {
        await handleAssignTrainer(values.classId, values.trainerId);
        alert('Entrenador asignado con éxito');
        formik.resetForm();
      } catch (err: any) {
        console.error('Error al asignar entrenador:', err);
      }
    },
  });

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Asignar Entrenador a Clase
      </Typography>
      <Box component="form" onSubmit={formik.handleSubmit} noValidate sx={{ mt: 2 }}>
        <TextField
          fullWidth
          label="ID de la Clase"
          name="classId"
          type="number"
          value={formik.values.classId}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          error={formik.touched.classId && Boolean(formik.errors.classId)}
          helperText={formik.touched.classId && formik.errors.classId}
          margin="normal"
        />
        <TextField
          fullWidth
          label="ID del Entrenador"
          name="trainerId"
          type="number"
          value={formik.values.trainerId}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          error={formik.touched.trainerId && Boolean(formik.errors.trainerId)}
          helperText={formik.touched.trainerId && formik.errors.trainerId}
          margin="normal"
        />
        {error && <Typography color="error">{error}</Typography>}
        <Button type="submit" variant="contained" color="primary" disabled={loading}>
          {loading ? 'Asignando...' : 'Asignar Entrenador'}
        </Button>
      </Box>
    </Container>
  );
};
import { useState } from 'react';

export const useSearch = () => {
  const [searchTerm, setSearchTerm] = useState('');

  return {
    searchTerm,
    setSearchTerm,
  };
};
// UserInterface.ts
export interface UserState {
    id?: string;
    username: string;
    password: string;
    email: string;
    admin: boolean;
    trainer: boolean;
      // Agregar la propiedad 'role'
    role: string;
    // O si manejas roles como un array:
    roles: string[];
    // Otros campos...
    profileImageUrl: string;
}
import React from 'react';
import { useFinancialData } from '../hooks/useFinancialData';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Container
} from '@mui/material';

export const DashboardAdmin: React.FC = () => {
  const { totalRevenue, adminRevenueData, loading, error } = useFinancialData();

  if (loading) return <p>Cargando datos...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <Container maxWidth="lg" sx={{ mt: 4 }}>
      {/* Título principal */}
      <Typography
        variant="h4"
        align="center"
        gutterBottom
        sx={{ fontWeight: 'bold' }}
      >
        Bienvenido al Dashboard del Administrador
      </Typography>

      <Grid container spacing={2}>
        {/* Card 1: Ingresos Totales */}
        {totalRevenue !== null && (
          <Grid item xs={12} sm={6} md={4}>
            <Card sx={{ boxShadow: 3 }}>
              <CardContent
                sx={{
                  backgroundColor: '#1976d2',
                  color: '#fff',
                  minHeight: '150px'
                }}
              >
                <Typography variant="h6" gutterBottom>
                  Ingresos Totales
                </Typography>
                <Typography variant="body1">
                  <strong>Total:</strong>{' '}
                  {totalRevenue.toLocaleString('es-AR', {
                    style: 'currency',
                    currency: 'ARS'
                  })}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        )}

        {/* Card 2: Ingresos por Plan */}
        {adminRevenueData && (
          <Grid item xs={12} sm={6} md={4}>
            <Card sx={{ boxShadow: 3 }}>
              <CardContent
                sx={{
                  backgroundColor: '#1976d2',
                  color: '#fff',
                  minHeight: '150px'
                }}
              >
                <Typography variant="h6" gutterBottom>
                  Ingresos por Plan
                </Typography>
                {Object.entries(adminRevenueData.planRevenue).map(([planName, amount]) => (
                  <Typography variant="body1" key={planName}>
                    {planName}:{' '}
                    {amount.toLocaleString('es-AR', {
                      style: 'currency',
                      currency: 'ARS'
                    })}
                  </Typography>
                ))}
              </CardContent>
            </Card>
          </Grid>
        )}

        {/* Card 3: Ingresos por Tipo de Servicio */}
        {adminRevenueData && (
          <Grid item xs={12} sm={6} md={4}>
            <Card sx={{ boxShadow: 3 }}>
              <CardContent
                sx={{
                  backgroundColor: '#1976d2',
                  color: '#fff',
                  minHeight: '150px'
                }}
              >
                <Typography variant="h6" gutterBottom>
                  Ingresos por Tipo de Servicio
                </Typography>
                <Typography variant="body1">
                  Entrenador Personal:{' '}
                  {adminRevenueData.serviceRevenue.personalTrainer.toLocaleString(
                    'es-AR',
                    { style: 'currency', currency: 'ARS' }
                  )}
                </Typography>
                <Typography variant="body1">
                  Plan + Entrenador:{' '}
                  {adminRevenueData.serviceRevenue.planAndTrainer.toLocaleString(
                    'es-AR',
                    { style: 'currency', currency: 'ARS' }
                  )}
                </Typography>
                <Typography variant="body1">
                  Solo Plan:{' '}
                  {adminRevenueData.serviceRevenue.plan.toLocaleString('es-AR', {
                    style: 'currency',
                    currency: 'ARS'
                  })}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        )}
      </Grid>
    </Container>
  );
};

export default DashboardAdmin;
// src/Admin/pages/AdminFacturasPage.tsx

import React from "react";
import {
  Table,
  TableContainer,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  Paper,
  Typography,
  CircularProgress,
  Alert,
  Box,
} from "@mui/material";
import { useParams } from "react-router-dom";
import { useFacturas } from "../hooks/useFacturas";
import { Paginator } from "../components/Paginator"; 
import { useSearch } from "../hooks/useSearch";

// Si ya tienes un componente de barra de búsqueda tipo "SearchBar"
import SearchBar from "../../components/common/SearchBar";

const AdminFacturasPage: React.FC = () => {
  // Lee el número de página de la URL
  const { page: pageParam } = useParams();
  const currentPage = parseInt(pageParam ?? "0", 10);

    // Hook de búsqueda reutilizable
    const { searchTerm, setSearchTerm } = useSearch();

  // Usa el hook para cargar facturas (paginadas)
  const { facturas, paginator, isLoading, error } = useFacturas(currentPage, searchTerm);





  if (isLoading) {
    return (
      <Box textAlign="center" mt={4}>
        <CircularProgress />
        <Typography variant="h6" mt={2}>
          Cargando pagos aprobados...
        </Typography>
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ mt: 4 }}>
        {error}
      </Alert>
    );
  }

  return (
    <div style={{ padding: "2rem" }}>
      <Typography variant="h4" gutterBottom>
        Facturas de Productos Aprobados
      </Typography>

      {/* Barra de Búsqueda */}
      <SearchBar
        placeholder="Buscar por usuario, producto, etc."
        value={searchTerm}
        onChange={setSearchTerm}
      />

{facturas.length === 0 ? (
  <Typography variant="h6" sx={{ mt: 2 }}>
    {searchTerm
      ? "No se encontraron resultados para tu búsqueda."
      : "No hay facturas disponibles."}
  </Typography>
) : (
  <TableContainer component={Paper} sx={{ mt: 2 }}>
    <Table aria-label="facturas de productos">
      <TableHead>
        <TableRow>
          <TableCell>ID del Pago</TableCell>
          <TableCell>Usuario</TableCell>
          <TableCell>Método de Pago</TableCell>
          <TableCell>Fecha de Pago</TableCell>
          <TableCell>Monto</TableCell>
          <TableCell>Producto</TableCell>
        </TableRow>
      </TableHead>
      <TableBody>
        {facturas.map((payment) => (
          <TableRow key={payment.paymentId}>
            <TableCell>{payment.paymentId}</TableCell>
            <TableCell>{payment.username}</TableCell>
            <TableCell>{payment.paymentMethod}</TableCell>
            <TableCell>
              {new Date(payment.paymentDate).toLocaleString("es-ES", {
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })}
            </TableCell>
            <TableCell>${payment.transactionAmount.toFixed(2)}</TableCell>
            <TableCell>{payment.productName}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </TableContainer>
)}
      {/* 
        Mostrar paginador SOLAMENTE si NO hay término de búsqueda
        y si hay más de una página en total
      */}
      {searchTerm === "" && (
        <Paginator
          url="/admin/facturas"
          paginator={{
            number: paginator.number,
            totalPages: paginator.totalPages,
            first: paginator.first,
            last: paginator.last,
          }}
        />
      )}
    </div>
  );
};

export default AdminFacturasPage;
import React, { useEffect, useState } from 'react';
import Swal from 'sweetalert2';
import {
  Container,
  Typography,
  Button,
  Table,
  TableHead,
  TableRow,
  TableBody,
  TableCell,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField
} from '@mui/material';
import apiClient from '../../Apis/apiConfig'; 

interface IPlan {
  id?: number;
  name: string;
  price: number;
  description?: string;
  discount?: number;
  discountReason?: string; 
  versionNumber?: number;
  active?: boolean;
  durationMonths?: number; 
}

const AdminPlanCrudPage: React.FC = () => {
  const [plans, setPlans] = useState<IPlan[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [openDialog, setOpenDialog] = useState(false);
  const [dialogMode, setDialogMode] = useState<'create' | 'edit'>('create');
  const [selectedPlanId, setSelectedPlanId] = useState<number | null>(null);

  // Estado del form
  const [planData, setPlanData] = useState<IPlan>({
    name: '',
    price: 0,
    description: '',
    discount: 0,
    discountReason: '',
    durationMonths: 1 
  });

  const fetchPlans = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await apiClient.get('/plans'); 
      setPlans(response.data);
    } catch (err: any) {
      console.error('Error al obtener planes:', err);
      setError('No se pudo obtener la lista de planes.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPlans();
  }, []);

  const handleOpenCreate = () => {
    setDialogMode('create');
    setPlanData({ name: '', price: 0, description: '', discount: 0, discountReason: '' });
    setSelectedPlanId(null);
    setOpenDialog(true);
  };

  const handleOpenEdit = (plan: IPlan) => {
    setDialogMode('edit');
    setSelectedPlanId(plan.id || null);
    setPlanData({
      name: plan.name,
      price: plan.price,
      description: plan.description || '',
      discount: plan.discount || 0,
      discountReason: plan.discountReason || '', // <-- nuevo
      versionNumber: plan.versionNumber,
      active: plan.active
    });
    setOpenDialog(true);
  };

  const handleSave = async () => {
    if (dialogMode === 'create') {
      try {
        await apiClient.post('/plans', planData);
        setOpenDialog(false);
        fetchPlans();
      } catch (err) {
        console.error('Error al crear plan:', err);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Ocurrió un error al crear el plan.',
        });
      }
    } else if (dialogMode === 'edit' && selectedPlanId) {
      try {
        await apiClient.put(`/plans/${selectedPlanId}`, planData);
        setOpenDialog(false);
        fetchPlans();
      } catch (err) {
        console.error('Error al actualizar plan:', err);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Ocurrió un error al actualizar el plan.',
        });
      }
    }
  };


  const handleArchive = async (id: number) => {
    const result = await Swal.fire({
      title: '¿Estás seguro?',
      text: "¿Quieres archivar (desactivar) este plan?",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Sí, archivar!',
      cancelButtonText: 'Cancelar'
    });

    if (!result.isConfirmed) return;
    
    try {
      await apiClient.delete(`/plans/${id}`);
      fetchPlans();
    } catch (err) {
      console.error('Error al archivar el plan:', err);
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: 'No se pudo archivar el plan.',
      });
    }
  };


  return (
    <Container maxWidth="lg">
      <Typography variant="h4" sx={{ my: 3 }}>
        Gestión de Planes
      </Typography>

      <Button variant="contained" color="primary" onClick={handleOpenCreate} sx={{ mb: 2 }}>
        Crear Nuevo Plan
      </Button>

      {loading && <Typography>Cargando planes...</Typography>}
      {error && <Typography color="error">{error}</Typography>}

      {!loading && !error && plans.length > 0 && (
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>Nombre</TableCell>
              <TableCell>Precio</TableCell>
              <TableCell>Descuento (%)</TableCell>
              <TableCell>Razón Descuento</TableCell>{/* Nuevo */}
              <TableCell>Versión</TableCell>
              <TableCell>Activo</TableCell>
              <TableCell>Acciones</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {plans.map((plan) => (
              <TableRow key={plan.id}>
                <TableCell>{plan.id}</TableCell>
                <TableCell>{plan.name}</TableCell>
                <TableCell>${plan.price}</TableCell>
                <TableCell>{plan.discount || 0}%</TableCell>
                <TableCell>{plan.discountReason || '--'}</TableCell>
                <TableCell>{plan.versionNumber}</TableCell>
                <TableCell>{plan.active ? 'Sí' : 'No'}</TableCell>
                <TableCell>
                  <Button
                    variant="contained"
                    size="small"
                    color="info"
                    onClick={() => handleOpenEdit(plan)}
                    sx={{ mr: 1 }}
                  >
                    Editar/Versionar
                  </Button>
                  <Button
                    variant="contained"
                    size="small"
                    color="warning"
                    onClick={() => handleArchive(plan.id!)}
                  >
                    Archivar
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}

      <Dialog open={openDialog} onClose={() => setOpenDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>
          {dialogMode === 'create' ? 'Crear Plan' : 'Editar / Versionar Plan'}
        </DialogTitle>
        <DialogContent>
          <TextField
            label="Nombre"
            variant="outlined"
            fullWidth
            margin="normal"
            value={planData.name}
            onChange={(e) => setPlanData({ ...planData, name: e.target.value })}
          />
          <TextField
            label="Precio"
            type="number"
            variant="outlined"
            fullWidth
            margin="normal"
            value={planData.price}
            onChange={(e) => setPlanData({ ...planData, price: Number(e.target.value) })}
          />
          <TextField
              label="Duración (meses)"
              type="number"
              variant="outlined"
              fullWidth
              margin="normal"
              value={planData.durationMonths}
              onChange={(e) => setPlanData({ ...planData, durationMonths: Number(e.target.value) })}
              inputProps={{ min: 1 }}
            />
          <TextField
            label="Descripción"
            variant="outlined"
            fullWidth
            margin="normal"
            value={planData.description}
            onChange={(e) => setPlanData({ ...planData, description: e.target.value })}
          />
          <TextField
            label="Descuento (%)"
            type="number"
            variant="outlined"
            fullWidth
            margin="normal"
            value={planData.discount}
            onChange={(e) => setPlanData({ ...planData, discount: Number(e.target.value) })}
          />
          <TextField
            label="Razón del Descuento"
            variant="outlined"
            fullWidth
            margin="normal"
            value={planData.discountReason}
            onChange={(e) => setPlanData({ ...planData, discountReason: e.target.value })}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpenDialog(false)} color="inherit">
            Cancelar
          </Button>
          <Button onClick={handleSave} variant="contained" color="primary">
            {dialogMode === 'create' ? 'Crear' : 'Guardar'}
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
};

export default AdminPlanCrudPage;
// src/Admin/pages/AdminPlanesPage.tsx

import React, { useEffect } from "react";
import {
  TableContainer,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  Paper,
  Typography,
  Alert,

} from "@mui/material";
import { useParams } from "react-router-dom";
import { usePlanes } from "../hooks/usePlanes";
import { Paginator } from "../components/Paginator";
// Reutiliza el mismo patrón de búsqueda
import { useSearch } from "../hooks/useSearch";
// Si tienes un SearchBar ya creado, por ejemplo:
import SearchBar from "../../components/common/SearchBar";

const AdminPlanesPage: React.FC = () => {
 
  // Obtenemos la página desde la URL
  const { page: pageParam } = useParams();
  const currentPage = parseInt(pageParam ?? "0", 10);

    // Hook de búsqueda reutilizable
    const { searchTerm, setSearchTerm } = useSearch();



    const { planes, paginator, error } = usePlanes(
      searchTerm ? 0 : currentPage, // Siempre usa página 0 para búsquedas
      searchTerm
    );


    const handleSearch = (term: string) => {
      setSearchTerm(term);
    };



  if (error) {
    return (
      <Alert severity="error" sx={{ mt: 4 }}>
        {error}
      </Alert>
    );
  }

  return (
    <div style={{ padding: "2rem" }}>
      <Typography variant="h4" gutterBottom>
        Facturas de Planes Aprobados
      </Typography>

      {/* Barra de búsqueda */}
      <SearchBar
        placeholder="Buscar por usuario"
        value={searchTerm}
        onChange={handleSearch}
      />

      {planes.length === 0 ? (
        <Typography variant="h6" sx={{ mt: 2 }}>
          {searchTerm
            ? "No se encontraron resultados para tu búsqueda."
            : "No hay facturas disponibles."}
        </Typography>
      ) : (
        <TableContainer component={Paper} sx={{ mt: 2 }}>
          <Table aria-label="facturas de planes">
            <TableHead>
              <TableRow>
                <TableCell>ID del Pago</TableCell>
                <TableCell>ID del Plan</TableCell>
                <TableCell>Usuario</TableCell>
                <TableCell>Método de Pago</TableCell>
                <TableCell>Fecha de Pago</TableCell>
                <TableCell>Monto</TableCell>
                <TableCell>Inicio Suscripción</TableCell>
                <TableCell>Fin Suscripción</TableCell>
                <TableCell>Inicio Subs. Entrenador</TableCell>
                <TableCell>Fin Subs. Entrenador</TableCell>
                <TableCell>Entrenador Personal</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {planes.map((payment) => (
                <TableRow key={payment.paymentId}>
                  <TableCell>{payment.paymentId}</TableCell>
                  <TableCell>{payment.planId}</TableCell>
                  <TableCell>{payment.username}</TableCell>
                  <TableCell>{payment.paymentMethod || "N/A"}</TableCell>
                  <TableCell>
                    {new Date(payment.paymentDate).toLocaleString("es-ES", {
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                      hour: "2-digit",
                      minute: "2-digit",
                    })}
                  </TableCell>
                  <TableCell>
                    $
                    {payment.transactionAmount.toLocaleString("es-ES", {
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2,
                    })}
                  </TableCell>
                  <TableCell>
                    {new Date(payment.subscriptionStartDate).toLocaleDateString("es-ES", {
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                    })}
                  </TableCell>
                  <TableCell>
                    {new Date(payment.subscriptionEndDate).toLocaleDateString("es-ES", {
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                    })}
                  </TableCell>
                  <TableCell>
                    {new Date(payment.trainerSubscriptionStartDate).toLocaleDateString("es-ES", {
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                    })}
                  </TableCell>
                  <TableCell>
                    {new Date(payment.trainerSubscriptionEndDate).toLocaleDateString("es-ES", {
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                    })}
                  </TableCell>
                  <TableCell>{payment.personalTrainerName || "N/A"}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}

      {/* 
        Muestra el paginador solo si NO hay término de búsqueda 
        y si hay más de una página de resultados
      */}
      {searchTerm === "" && (
        <Paginator
          url="/admin/planes"
          paginator={{
            number: paginator.number,
            totalPages: paginator.totalPages,
            first: paginator.first,
            last: paginator.last,
          }}
        />
      )}
    </div>
  );
};

export default AdminPlanesPage;
import React from 'react';
import AdminTrainerAvailabilityForm from '../components/forms/AdminTrainerAvailabilityForm';

const AssignTrainerAvailabilityPage: React.FC = () => {
  return (
    <div style={{ padding: '20px' }}>
      <h2>Asignar Horarios a Entrenador</h2>
      <AdminTrainerAvailabilityForm />
    </div>
  );
};

export default AssignTrainerAvailabilityPage;
import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Typography,
  Grid,
  Card,
  CardMedia,
  CardContent,
  CardActions,
  Modal,
  TextField,
} from '@mui/material';
import { getCarouselImages, uploadCarouselImage, updateCarouselImage, deleteCarouselImage } from '../../Admin/services/carouselService';


const CarouselAdminPage: React.FC = () => {
  const [images, setImages] = useState<any[]>([]);
  const [openModal, setOpenModal] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [caption, setCaption] = useState('');
  const [orderNumber, setOrderNumber] = useState<number>(0);
  const [editingId, setEditingId] = useState<number | null>(null);


  useEffect(() => {
    fetchImages();
  }, []);

  const fetchImages = async () => {
    try {
      const data = await getCarouselImages();
      console.log("ACA LA DATA DEL CARROUSEL",data);
      setImages(data);
    } catch (error) {
      console.error('Error al obtener imágenes:', error);
    }
  };

  const handleOpenModal = (image?: any) => {
    if (image) {
      setEditingId(image.id);
      setCaption(image.caption);
      setOrderNumber(image.orderNumber);
    } else {
      setEditingId(null);
      setCaption('');
      setOrderNumber(0);
    }
    setOpenModal(true);
  };

  const handleCloseModal = () => {
    setOpenModal(false);
    setSelectedFile(null);
    setCaption('');
    setOrderNumber(0);
    setEditingId(null);
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files.length > 0) {
      setSelectedFile(event.target.files[0]);
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) return;
    try {
      await uploadCarouselImage(selectedFile, caption, orderNumber);
      fetchImages();
      handleCloseModal();
    } catch (error) {
      console.error('Error al subir imagen:', error);
    }
  };
  


  const handleUpdate = async () => {
    if (editingId === null) return;
  
    try {
      const formData = new FormData();
      formData.append('caption', caption);
      formData.append('order', orderNumber.toString());
  
      // Incluir archivo solo si se seleccionó uno nuevo
      if (selectedFile) {
        formData.append('file', selectedFile);
      }
  
      console.log('FormData enviado:', formData);
  
      // Llamar al servicio con el FormData
      await updateCarouselImage(editingId, formData);
      fetchImages(); // Refrescar las imágenes
      handleCloseModal(); // Cerrar el modal
    } catch (error) {
      console.error('Error al actualizar imagen:', error);
    }
  };
  
  
  
  const handleDelete = async (id: number) => {
    try {
      await deleteCarouselImage(id);
      fetchImages();
    } catch (error) {
      console.error('Error al eliminar imagen:', error);
    }
  };
  

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Administrador de Carrusel
      </Typography>
      <Button variant="contained" color="primary" onClick={() => handleOpenModal()}>
        Agregar Nueva Imagen
      </Button>
      <Grid container spacing={2} sx={{ mt: 2 }}>
        {images.map((image) => (
          <Grid item xs={12} sm={6} md={4} key={image.id}>
            <Card>
              <CardMedia
                component="img"
                height="140"
                image={image.imageUrl}
                alt={image.caption}
              />
              <CardContent>
                <Typography variant="h6">{image.caption}</Typography>
                <Typography variant="body2" color="textSecondary">
                  Orden: {image.orderNumber}
                </Typography>
              </CardContent>
              <CardActions>
                <Button size="small" color="secondary" onClick={() => handleOpenModal(image)}>
                  Editar
                </Button>
                <Button size="small" color="error" onClick={() => handleDelete(image.id)}>
                  Eliminar
                </Button>
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Modal para agregar o editar imagen */}
      <Modal open={openModal} onClose={handleCloseModal}>
  <Box
    sx={{
      position: 'absolute' as const,
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: 400,
      bgcolor: 'background.paper',
      boxShadow: 24,
      p: 4,
    }}
  >
    <Typography variant="h6" gutterBottom>
      {editingId ? 'Editar Imagen' : 'Subir Nueva Imagen'}
    </Typography>
    <TextField
      fullWidth
      label="Título"
      value={caption ?? ''}
      onChange={(e) => setCaption(e.target.value)}
      sx={{ mb: 2 }}
    />
    <TextField
      fullWidth
      label="Orden"
      type="number"
      value={orderNumber ?? 0}
      onChange={(e) => setOrderNumber(Number(e.target.value))}
      sx={{ mb: 2 }}
    />

    <Button variant="contained" component="label" fullWidth>
      {selectedFile ? 'Cambiar Imagen' : 'Seleccionar Imagen'}
      <input type="file" hidden onChange={handleFileChange} />
    </Button>
    {selectedFile && <Typography sx={{ mt: 1 }}>{selectedFile.name}</Typography>}

    {/* Contenedor para centrar el botón */}
    <Box
      sx={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        mt: 2,
      }}
    >
      <Button
        variant="contained"
        color="primary"
        onClick={editingId ? handleUpdate : handleUpload}
        disabled={!selectedFile && !editingId}
      >
        {editingId ? 'Actualizar' : 'Subir'}
      </Button>
    </Box>
  </Box>
</Modal>

    </Box>
  );
};

export default CarouselAdminPage;
import React, { useEffect, useState } from 'react';
import apiClient from '../../Apis/apiConfig';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import Swal from 'sweetalert2';
// Importaciones de Material UI
import {
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  Paper,
  Box,
} from '@mui/material';

// Interfaces
interface Category {
  id?: number;
  name: string;
}

export const CategoryCrud: React.FC = () => {
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(
    null
  );
  const [openDialog, setOpenDialog] = useState(false);

  useEffect(() => {
    fetchCategories();
  }, []);

  // Obtener todas las categorías
  const fetchCategories = async () => {
    try {
      const response = await apiClient.get<Category[]>('/store/categories');
      setCategories(response.data);
    } catch (error) {
      console.error('Error al obtener categorías:', error);
    }
  };

  const handleDelete = async (categoryId: number) => {
    const result = await Swal.fire({
      title: '¿Estás seguro?',
      text: "¡Todos los productos de esta categoría serán desactivados!",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Sí, eliminar',
      cancelButtonText: 'Cancelar'
    });

    if (result.isConfirmed) {
      try {
        await apiClient.delete(`/store/categories/${categoryId}`);
        await fetchCategories();
        Swal.fire(
          '¡Eliminada!',
          'La categoría y sus productos han sido desactivados.',
          'success'
        );
      } catch (error) {
        console.error('Error al eliminar categoría:', error);
        Swal.fire(
          'Error',
          'Ocurrió un error al eliminar la categoría',
          'error'
        );
      }
    }
  };

  // Abrir modal para CREAR nueva categoría
  const handleOpenCreate = () => {
    setSelectedCategory(null);
    setOpenDialog(true);
  };

  // Abrir modal para EDITAR categoría
  const handleEdit = (category: Category) => {
    setSelectedCategory(category);
    setOpenDialog(true);
  };

  // Cerrar modal
  const handleCloseDialog = () => {
    setSelectedCategory(null);
    setOpenDialog(false);
  };

  // Validación con Yup
  const validationSchema = Yup.object().shape({
    name: Yup.string().required('El nombre es requerido'),
  });

  // Manejar envío del formulario (crear/actualizar)
  const handleSubmit = async (values: any, { resetForm }: any) => {
    try {
      if (selectedCategory) {
        await apiClient.put(`/store/categories/${selectedCategory.id}`, null, {
          params: { newName: values.name },
        });
      } else {
        await apiClient.post('/store/categories', null, {
          params: { name: values.name },
        });
      }

      await fetchCategories();
      
      Swal.fire({
        icon: 'success',
        title: selectedCategory ? '¡Actualizada!' : '¡Creada!',
        text: selectedCategory 
          ? 'La categoría ha sido actualizada correctamente.' 
          : 'La categoría ha sido creada correctamente.',
      });

      resetForm();
      handleCloseDialog();
    } catch (error) {
      console.error('Error al guardar categoría:', error);
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: 'Ocurrió un error al procesar la solicitud',
      });
    }
  };

  return (
    <Box sx={{ margin: '2rem' }}>
      <Typography variant="h4" gutterBottom>
        Gestión de Categorías
      </Typography>

      {/* Botón para crear una nueva categoría */}
      <Button
        variant="contained"
        color="primary"
        onClick={handleOpenCreate}
        sx={{ mb: 2 }}
      >
        Crear Categoría
      </Button>

      {/* Listado de categorías */}
      {categories.length === 0 ? (
        <Typography>No hay categorías registradas.</Typography>
      ) : (
        <TableContainer component={Paper} sx={{ mb: 2 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell><strong>ID</strong></TableCell>
                <TableCell><strong>Nombre</strong></TableCell>
                <TableCell><strong>Acciones</strong></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {categories.map((cat) => (
                <TableRow key={cat.id}>
                  <TableCell>{cat.id}</TableCell>
                  <TableCell>{cat.name}</TableCell>
                  <TableCell>
                    <Button
                      variant="outlined"
                      color="primary"
                      onClick={() => handleEdit(cat)}
                      sx={{ mr: 1 }}
                    >
                      Editar
                    </Button>
                    <Button
                      variant="outlined"
                      color="error"
                      onClick={() => cat.id && handleDelete(cat.id)}
                    >
                      Eliminar
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}

      {/* Dialog (Modal) para crear/editar categoría */}
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        fullWidth
        maxWidth="sm"
      >
        <Formik
          initialValues={{
            name: selectedCategory?.name || '',
          }}
          enableReinitialize
          validationSchema={validationSchema}
          onSubmit={handleSubmit}
        >
          {({ handleSubmit, values }) => (
            <Form onSubmit={handleSubmit}>
              <DialogTitle>
                {selectedCategory ? 'Editar Categoría' : 'Crear Categoría'}
              </DialogTitle>

              <DialogContent dividers>
                {/* CAMPO NOMBRE */}
                <Field name="name">
                  {({ field }: any) => (
                    <TextField
                      {...field}
                      label="Nombre de la categoría"
                      fullWidth
                      margin="normal"
                    />
                  )}
                </Field>
                <ErrorMessage
                  name="name"
                  render={(msg) => (
                    <Typography color="error" variant="body2">
                      {msg}
                    </Typography>
                  )}
                />
              </DialogContent>

              <DialogActions>
                <Button onClick={handleCloseDialog}>Cancelar</Button>
                <Button type="submit" variant="contained" color="primary">
                  {selectedCategory ? 'Actualizar' : 'Crear'}
                </Button>
              </DialogActions>
            </Form>
          )}
        </Formik>
      </Dialog>
    </Box>
  );
};

export default CategoryCrud;
import React, { useState, useEffect } from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import { TextField, Button, Box, Typography, Container, MenuItem, FormControl, InputLabel, Select, CircularProgress, Alert } from '@mui/material';
import { DatePicker, TimePicker, LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format } from 'date-fns';
import Swal from 'sweetalert2';
import { useGroupClasses } from '../../Admin/hooks/useGroupClasses';
import { fetchAvailableTrainers } from '../../Admin/services/AvailabilityRequest';

export const GroupClassesCreatePage: React.FC = () => {
  const { handleCreateClass, loading, error } = useGroupClasses();
  const [availableTrainers, setAvailableTrainers] = useState([]);
  const [loadingTrainers, setLoadingTrainers] = useState(false);
  const [fetchError, setFetchError] = useState('');
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitSuccess, setSubmitSuccess] = useState<boolean>(false);

 
  const validationSchema = Yup.object({
    className: Yup.string().required('El nombre de la clase es requerido'),
    day: Yup.date().required('Selecciona un día'),
    startTime: Yup.date().required('Selecciona la hora de inicio'),
    endTime: Yup.date()
      .required('Selecciona la hora de fin')
      .test('is-after-start', 'La hora de fin debe ser después de la hora de inicio', function (value) {
        const { startTime } = this.parent;
        return value && startTime && value > startTime;
      }),
    maxParticipants: Yup.number()
      .required('El número máximo de participantes es requerido')
      .min(1, 'Debe ser mayor a 0'),
    trainerId: Yup.number().required('Selecciona un entrenador'),
  });

  const formik = useFormik({
    initialValues: {
      className: '',
      day: null as Date | null,
      startTime: null as Date | null,
      endTime: null as Date | null,
      maxParticipants: 20,
      trainerId: '',
    },
    validationSchema,
    onSubmit: async (values) => {
      setSubmitError(null);
      setSubmitSuccess(false);

      try {
        const dayStr = values.day ? format(values.day, 'yyyy-MM-dd') : '';
        const startTimeStr = values.startTime ? format(values.startTime, 'HH:mm') : '';
        const endTimeStr = values.endTime ? format(values.endTime, 'HH:mm') : '';

        const requestData = {
          className: values.className,
          day: dayStr,
          startTime: startTimeStr,
          endTime: endTimeStr,
          maxParticipants: values.maxParticipants,
          trainerId: values.trainerId,
        };

        await handleCreateClass(requestData);
        Swal.fire({
          title: 'Clase creada con éxito',
          icon: 'success',
          confirmButtonText: 'OK',
        });
        formik.resetForm();
        setSubmitSuccess(true);
      } catch (err: any) {
        setSubmitError('Error al crear la clase');
      }
    },
  });

  useEffect(() => {
    const fetchTrainers = async () => {
      if (formik.values.day && formik.values.startTime && formik.values.endTime) {
        setLoadingTrainers(true);
        try {
          const dayStr = format(formik.values.day, 'yyyy-MM-dd');
          const startTimeStr = format(formik.values.startTime, 'HH:mm');
          const endTimeStr = format(formik.values.endTime, 'HH:mm');
  
          const trainers = await fetchAvailableTrainers(dayStr, startTimeStr, endTimeStr);
          setAvailableTrainers(trainers);
        } catch (err) {
          setFetchError('Error al obtener entrenadores disponibles');
        } finally {
          setLoadingTrainers(false);
        }
      }
    };
  
    fetchTrainers();
  }, [formik.values.day, formik.values.startTime, formik.values.endTime]); 


  if (loading) {
    return <CircularProgress />;
  }

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Crear Clase Grupal
      </Typography>
      <Box component="form" onSubmit={formik.handleSubmit} noValidate sx={{ mt: 2 }}>
        <TextField
          fullWidth
          label="Nombre de la Clase"
          name="className"
          value={formik.values.className}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          error={formik.touched.className && Boolean(formik.errors.className)}
          helperText={formik.touched.className && formik.errors.className}
          margin="normal"
        />

        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DatePicker
            label="Día de la Clase"
            value={formik.values.day}
            onChange={(newValue) => formik.setFieldValue('day', newValue)}
            renderInput={(params) => (
              <TextField
                {...params}
                fullWidth
                margin="normal"
                error={formik.touched.day && Boolean(formik.errors.day)}
                helperText={formik.touched.day && formik.errors.day}
              />
            )}
          />

<TimePicker
  label="Hora de Inicio"
  value={formik.values.startTime}
  ampm={true}  // Habilitar AM/PM
  onChange={(newValue) => formik.setFieldValue('startTime', newValue)}
  renderInput={(params) => (
    <TextField
      {...params}
      fullWidth
      margin="normal"
      error={formik.touched.startTime && Boolean(formik.errors.startTime)}
      helperText={formik.touched.startTime && formik.errors.startTime}
    />
  )}
/>

<TimePicker
  label="Hora de Fin"
  value={formik.values.endTime}
  ampm={true}  // Habilitar AM/PM
  onChange={(newValue) => formik.setFieldValue('endTime', newValue)}
  renderInput={(params) => (
    <TextField
      {...params}
      fullWidth
      margin="normal"
      error={formik.touched.endTime && Boolean(formik.errors.endTime)}
      helperText={formik.touched.endTime && formik.errors.endTime}
    />
  )}
/>
        </LocalizationProvider>

        <TextField
          fullWidth
          label="Máximo de participantes"
          name="maxParticipants"
          type="number"
          value={formik.values.maxParticipants}
          onChange={formik.handleChange}
          onBlur={formik.handleBlur}
          error={formik.touched.maxParticipants && Boolean(formik.errors.maxParticipants)}
          helperText={formik.touched.maxParticipants && formik.errors.maxParticipants}
          margin="normal"
        />

        <FormControl fullWidth margin="normal">
          <InputLabel id="trainer-select-label">Entrenador Disponible</InputLabel>
          <Select
            labelId="trainer-select-label"
            id="trainerId"
            name="trainerId"
            value={formik.values.trainerId}
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
          >
            {availableTrainers.map((trainer) => (
              <MenuItem key={trainer.id} value={trainer.id}>
                {trainer.username}
              </MenuItem>
            ))}
          </Select>
        </FormControl>

        {submitError && <Alert severity="error">{submitError}</Alert>}
        {submitSuccess && <Alert severity="success">Clase creada con éxito</Alert>}

        <Button type="submit" variant="contained" color="primary" sx={{ mt: 2 }}>
          Crear Clase
        </Button>
      </Box>
    </Container>
  );
};
// src/Admin/pages/GymInfoForm.tsx
import React, { useEffect, useState } from 'react';
import { Formik, Form } from 'formik';
import * as Yup from 'yup';
import {
  TextField,
  Button,
  Grid,
  Box,
  Typography,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Paper,
  Stack
} from '@mui/material';
import { createGymInfo, getGymInfo, updateGymInfo } from '../../Admin/services/gymInfoService';
import EditIcon from '@mui/icons-material/Edit';

export interface GymInfoValues {
  id?: number;
  gymName: string;
  address: string;
  phone: string;
  email: string;
  instagram: string;
  facebook: string;
  whatsapp: string;
  twitter: string;
}

const GymInfoSchema = Yup.object().shape({
  gymName: Yup.string().required('El nombre del gym es requerido'),
  address: Yup.string().required('La dirección es requerida'),
  phone: Yup.string().required('El teléfono es requerido'),
  email: Yup.string().email('Email inválido').required('El email es requerido'),
  instagram: Yup.string().url('URL inválida').notRequired(),
  facebook: Yup.string().url('URL inválida').notRequired(),
  twitter: Yup.string().url('URL inválida').notRequired(),
});

const GymInfoForm: React.FC = () => {
  const [initialValues, setInitialValues] = useState<GymInfoValues>({
    gymName: '',
    address: '',
    phone: '',
    email: '',
    instagram: '',
    facebook: '',
    whatsapp: '',
    twitter: '',
  });

  const [openModal, setOpenModal] = useState(false);
  const [existingData, setExistingData] = useState<GymInfoValues | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await getGymInfo();
        console.log("aqui esta la data",data);
        if (data) {
          setInitialValues(data);
          setExistingData(data);
        }
      } catch (error) {
        console.error('Error cargando información:', error);
      }
    };
    fetchData();
  }, []);

  const handleOpenModal = () => setOpenModal(true);
  const handleCloseModal = () => setOpenModal(false);

  const handleSubmit = async (values: GymInfoValues) => {
    try {
      let savedData;
      if (values.id) {
        savedData = await updateGymInfo(values.id, values);
      } else {
        savedData = await createGymInfo(values);
      }
      setInitialValues(savedData);
      setExistingData(savedData);
      handleCloseModal();
    } catch (error) {
      console.error('Error guardando:', error);
    }
  };

  return (
    <Box sx={{ maxWidth: 800, margin: '2rem auto', padding: 2 }}>
      <Typography variant="h4" align="center" gutterBottom>
        Información del Gym
      </Typography>

      {existingData ? (
        <Paper elevation={3} sx={{ padding: 3, marginBottom: 3 }}>
          <Stack spacing={2}>
            <Box display="flex" justifyContent="space-between" alignItems="center">
              <Typography variant="h6">Información Actual</Typography>
              <Button
                variant="contained"
                color="primary"
                startIcon={<EditIcon />}
                onClick={handleOpenModal}
              >
                Editar
              </Button>
            </Box>
            
            <Typography><strong>Nombre:</strong> {existingData.gymName}</Typography>
            <Typography><strong>Dirección:</strong> {existingData.address}</Typography>
            <Typography><strong>Teléfono:</strong> {existingData.phone}</Typography>
            <Typography><strong>Email:</strong> {existingData.email}</Typography>
            
            <Divider sx={{ my: 2 }} />
            
            <Typography variant="h6">Redes Sociales</Typography>
            {existingData.instagram && <Typography><strong>Instagram:</strong> {existingData.instagram}</Typography>}
            {existingData.facebook && <Typography><strong>Facebook:</strong> {existingData.facebook}</Typography>}
            {existingData.whatsapp && <Typography><strong>WhatsApp:</strong> {existingData.whatsapp}</Typography>}
            {existingData.twitter && <Typography><strong>Twitter:</strong> {existingData.twitter}</Typography>}
          </Stack>
        </Paper>
      ) : (
        <Box textAlign="center" mb={3}>
          <Button
            variant="contained"
            color="primary"
            size="large"
            onClick={handleOpenModal}
          >
            Crear Información del Gym
          </Button>
        </Box>
      )}

      <Dialog open={openModal} onClose={handleCloseModal} fullWidth maxWidth="md">
        <DialogTitle>
          {existingData ? 'Editar Información del Gym' : 'Crear Información del Gym'}
        </DialogTitle>
        
        <Formik
          initialValues={initialValues}
          enableReinitialize={true}
          validationSchema={GymInfoSchema}
          onSubmit={handleSubmit}
        >
          {({
            values,
            errors,
            touched,
            handleChange,
            handleBlur,
            isSubmitting,
          }) => (
            <Form>
              <DialogContent>
                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="gymName"
                      name="gymName"
                      label="Nombre del Gym"
                      value={values.gymName}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.gymName && Boolean(errors.gymName)}
                      helperText={touched.gymName && errors.gymName}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="address"
                      name="address"
                      label="Dirección"
                      value={values.address}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.address && Boolean(errors.address)}
                      helperText={touched.address && errors.address}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="phone"
                      name="phone"
                      label="Teléfono"
                      value={values.phone}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.phone && Boolean(errors.phone)}
                      helperText={touched.phone && errors.phone}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="email"
                      name="email"
                      label="Email"
                      value={values.email}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.email && Boolean(errors.email)}
                      helperText={touched.email && errors.email}
                    />
                  </Grid>

                  <Grid item xs={12}>
                    <Divider sx={{ margin: '1rem 0' }} />
                    <Typography variant="h6" align="center">
                      Redes Sociales
                    </Typography>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="instagram"
                      name="instagram"
                      label="Instagram URL"
                      value={values.instagram}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.instagram && Boolean(errors.instagram)}
                      helperText={touched.instagram && errors.instagram}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="facebook"
                      name="facebook"
                      label="Facebook URL"
                      value={values.facebook}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.facebook && Boolean(errors.facebook)}
                      helperText={touched.facebook && errors.facebook}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="whatsapp"
                      name="whatsapp"
                      label="Whatsapp URL"
                      value={values.whatsapp}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.whatsapp && Boolean(errors.whatsapp)}
                      helperText={touched.whatsapp && errors.whatsapp}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      id="twitter"
                      name="twitter"
                      label="Twitter URL"
                      value={values.twitter}
                      onChange={handleChange}
                      onBlur={handleBlur}
                      error={touched.twitter && Boolean(errors.twitter)}
                      helperText={touched.twitter && errors.twitter}
                    />
                  </Grid>
                </Grid>
              </DialogContent>

              <DialogActions>
                <Button onClick={handleCloseModal}>Cancelar</Button>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={isSubmitting}
                >
                  {existingData ? 'Actualizar' : 'Crear'}
                </Button>
              </DialogActions>
            </Form>
          )}
        </Formik>
      </Dialog>
    </Box>
  );
};

export default GymInfoForm;// src/components/ProductCrud/ProductCrud.tsx

import React from 'react';
import { useParams } from 'react-router-dom';
import { Box, Typography, TextField, Button, Paper, TableContainer } from '@mui/material';
import { useSearch } from '../../Admin/hooks/useSearch';
import { Paginator } from '../components/Paginator';
import { ProductList } from '../components/ProductList';
import { ProductModalForm } from '../components/ProductModalForm';
import { useProductCrud } from '../hooks/useProductCrud';

export const ProductCrud: React.FC = () => {
  const { searchTerm, setSearchTerm } = useSearch();
  const { page = '0' } = useParams();
  const currentPage = parseInt(page, 10);

  // Hook que maneja toda la lógica
  const {
    products,
    paginator,
    categories,
    selectedProduct,
    openDialog,

    handlerCreateProduct,
    handlerUpdateProduct,
    handlerDeleteProduct,
    handleOpenCreate,
    handleEdit,
    handleCloseDialog,
  } = useProductCrud(currentPage, searchTerm);

  return (
    <Box sx={{ margin: '2rem' }}>
      <Typography variant="h4" gutterBottom>
        Gestión de Productos
      </Typography>

      {/* Botón crear */}
      <Button
        variant="contained"
        color="primary"
        onClick={handleOpenCreate}
        sx={{ mb: 2, mr: 2 }}
      >
        Crear Producto
      </Button>

      {/* Barra de búsqueda */}
      <TextField
        label="Buscar productos..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        size="small"
        sx={{ mb: 2, width: '300px' }}
      />

      {products.length === 0 ? (
        <Typography>No hay productos registrados.</Typography>
      ) : (
        <TableContainer component={Paper} sx={{ mb: 2 }}>
          <ProductList
            products={products}
            onEdit={handleEdit}
            onDelete={handlerDeleteProduct}
          />
        </TableContainer>
      )}

      {/* Modal Form */}
      <ProductModalForm
        open={openDialog}
        onClose={handleCloseDialog}
        productSelected={selectedProduct}
        categories={categories}
        onCreate={handlerCreateProduct}
        onUpdate={handlerUpdateProduct}
      />

      {/* Paginador */}
      {paginator.totalPages > 1 && (
        <Paginator
          url="/admin/store/products"
          paginator={{
            number: paginator.number,
            totalPages: paginator.totalPages,
            first: paginator.first,
            last: paginator.last,
          }}
        />
      )}
    </Box>
  );
};
export default ProductCrud; import React, { useEffect } from "react";
import { useAuth } from "../../Auth/hooks/useAuth";
import { useUsers } from "../hooks/useUsers";
import { UserModalForm } from "../components/useModalForm";
import { UsersList } from "../components/UsersList";
import { Box, Button, Typography } from '@mui/material';
import { useLocation, useParams } from "react-router-dom";
import { Paginator } from "../components/Paginator";
import SearchBar from "../../components/common/SearchBar";

export const UsersPage = () => {
  const { page: pageParam } = useParams();
  // Si no existe, fallback a '0'
  const currentPage = parseInt(pageParam ?? '0', 10);


    const {
        users,
        visibleForm,
        handlerOpenForm,
        paginator,
        searchTerm,
        setSearchTerm,
        getUsers,
      } = useUsers();

    const { login } = useAuth();

    useEffect(() => {
        getUsers(currentPage);  // Llamamos a getUsers con la página correcta
    }, [currentPage, searchTerm]);  // Escuchamos los cambios de página y términos de búsqueda

    return (
        <>
          {visibleForm && <UserModalForm />}
          <Box sx={{ p: 3 }}>
            <Typography variant="h4" gutterBottom>
              Users App
            </Typography>
            {(visibleForm || !login.isAdmin) || (
              <Button
                variant="contained"
                color="primary"
                onClick={handlerOpenForm}
                sx={{ mb: 2 }}
              >
                Nuevo Usuario
              </Button>
            )}
            {/* Barra de búsqueda */}
            <SearchBar
              placeholder="Buscar usuarios..."
              value={searchTerm}
              onChange={setSearchTerm}
            />
            {users.length === 0 ? (
              <Typography variant="body1">
                No hay usuarios en el sistema!
              </Typography>
            ) : (
              <>
                <UsersList />
                {/* Mostrar el paginador solo si no hay término de búsqueda */}
                {searchTerm === '' && (
                  <Paginator
                  url="/admin/users"
                  paginator={{
                    number: paginator.number,
                    totalPages: paginator.totalPages,
                    first: paginator.first,
                    last: paginator.last,
                  }}
                />
                
                )}
              </>
            )}
          </Box>
        </>
      );
};
// src/Admin/services/availabilityService.ts

import apiClient from '../../Apis/apiConfig';

export interface PersonalTrainerDto {
  id: number;
  username: string;
  email: string;
  specialization: string;
  experienceYears: number;
  availability: boolean;
  profileImageUrl: string;
  title: string;
  studies: string;
  certifications: string;
  description: string;
}

export interface TrainerAvailabilityRequest {
  day: string;       // "YYYY-MM-DD"
  startTime: string; // "HH:mm"
  endTime: string;   // "HH:mm"
}

export const fetchAvailableTrainers = async (
  day: string,        // "YYYY-MM-DD"
  startTime: string,  // "HH:mm"
  endTime: string     // "HH:mm"
): Promise<PersonalTrainerDto[]> => {
  const response = await apiClient.get('/trainer-schedule/available', {  // Endpoint corregido
    params: { day, startTime, endTime },
  });
  console.log("ACA LA RESPONSE", response);
  return response.data;
};


import apiClient from '../../Apis/apiConfig';

// Obtener todas las imágenes del carrusel
export const getCarouselImages = async () => {
  try {
    const response = await apiClient.get('/carousel/images');
    return response.data;
  } catch (error) {
    console.error('Error al obtener imágenes del carrusel:', error);
    throw error;
  }
};

// Subir una nueva imagen al carrusel
export const uploadCarouselImage = async (
    file: File,
    caption: string,
    orderNumber: number
  ) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('caption', caption);
    formData.append('order', orderNumber.toString());
  
    try {
      const response = await apiClient.post('/carousel/images', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error al subir la imagen del carrusel:', error);
      throw error;
    }
  };
  
  // Actualizar una imagen existente
  export const updateCarouselImage = async (
    id: number,
    caption?: string,
    orderNumber?: number
  ) => {
    console.log(id,
      caption,
      orderNumber)
    const formData = new FormData();
    if (caption) formData.append('caption', caption);
    if (orderNumber !== undefined) formData.append('order', orderNumber.toString());
  
    try {
      const response = await apiClient.put(`/carousel/images/${id}`, formData);
      console.log("response",response);
      return response.data;
    } catch (error) {
      console.error('Error al actualizar la imagen:', error);
      throw error;
    }
  };
  
  // Eliminar una imagen del carrusel
  export const deleteCarouselImage = async (id: number) => {
    try {
      await apiClient.delete(`/carousel/images/${id}`);
    } catch (error) {
      console.error('Error al eliminar la imagen del carrusel:', error);
      throw error;
    }
  };
  // src/Admin/services/facturaService.ts

import apiClient from "../../Apis/apiConfig";
import { AxiosResponse } from "axios";
// import { PaymentPlanDTO } from "./FinancialService";
import { PaymentPlanDTO, PaymentProductDTO  }from "../../Store/interface/Payment"


export interface FacturasPage {
  content: PaymentProductDTO[];
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

export interface PlanesPage {
  content: PaymentPlanDTO[];
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

/*
export interface PaymentPlanDTO {
  paymentId: number;
  planId: number;
  username: string;
  transactionAmount: number;
  status: string;
  paymentMethod: string | null;
  paymentDate: string; // o Date
  subscriptionStartDate: string; // "2024-12-07"
  subscriptionEndDate: string;   // "2025-12-07"
  trainerSubscriptionStartDate: string; 
  trainerSubscriptionEndDate: string;
  personalTrainerName: string;
} */

  export const getFacturasPage = async (
    page: number,
    size = 6,
    search = ""
  ): Promise<AxiosResponse<FacturasPage>> => {
    return apiClient.get(`/payment/approved_products/page/${page}`, {
      params: { size, search },
    });
  };
  

  export const getPlanesPage = async (
    page: number,
    size = 6,
    search = ""
  ): Promise<AxiosResponse<PlanesPage>> => {
    return apiClient.get(`/payment/approved_plans/page/${page}`, {
      params: { size, search }, // Agregamos el parámetro de búsqueda
    });
  };
import apiClient from '../../Apis/apiConfig';

export const getTotalRevenue = async (): Promise<number> => {
  const response = await apiClient.get('/payment/total-revenue');
  // La respuesta tiene la forma { "totalRevenue": 7795000.00 }
  return response.data.totalRevenue;
};

export interface PlanRevenue {
  [planName: string]: number;
}

export interface ServiceRevenue {
  personalTrainer: number;
  planAndTrainer: number;
  plan: number;
}

export interface AdminDashboardRevenue {
  planRevenue: PlanRevenue;
  serviceRevenue: ServiceRevenue;
}

export const getAdminDashboardRevenue = async (): Promise<AdminDashboardRevenue> => {
  const response = await apiClient.get('/payment/admin-dashboard-revenue');
  // Estructura:
  // {
  //   "planRevenue": {
  //       "Trimestral": 230000.00,
  //       "mensual": 475000.00,
  //       "anual": 800000.00
  //   },
  //   "serviceRevenue": {
  //       "personalTrainer": 1060000.00,
  //       "planAndTrainer": 6075000.00,
  //       "plan": 85000.00
  //   }
  // }
  return response.data;
};
// src/api/groupClassService.ts
import apiClient from '../../Apis/apiConfig';

export interface CreateGroupClassData {
  className: string;
  startTime: string;   // formato ISO 8601, ej: '2024-12-19T08:00:00'
  endTime: string;
  maxParticipants: number;
}

export const createGroupClass = async (data: CreateGroupClassData) => {
  const response = await apiClient.post('/group-classes/create', data);
  return response.data;
};

export const assignTrainerToClass = async (classId: number, trainerId: number) => {
  const response = await apiClient.post(`/group-classes/${classId}/assign-trainer?trainerId=${trainerId}`);
  return response.data;
};
// src/api/gymInfoService.ts
import apiClient from '../../Apis/apiConfig';
import { GymInfoValues } from '../../Admin/pages/GymInfoForm';

export const createGymInfo = async (data: GymInfoValues) => {
    try {
      const response = await apiClient.post('/api/gym-info', data);
      return response.data;
    } catch (error) {
      console.error('Error al crear la información del gym:', error);
      throw error;
    }
  };
  
  // Nuevos métodos para obtener y actualizar
  export const getGymInfo = async (): Promise<GymInfoValues> => {
    try {
      const response = await apiClient.get('/api/gym-info');
      return response.data;
    } catch (error) {
      console.error('Error al obtener la información del gym:', error);
      throw error;
    }
  };
  
  export const updateGymInfo = async (id: number, data: GymInfoValues) => {
    try {
      const response = await apiClient.put(`/api/gym-info/${id}`, data);
      return response.data;
    } catch (error) {
      console.error('Error al actualizar la información del gym:', error);
      throw error;
    }
  };
import apiClient  from "../../Apis/apiConfig";
import { UserInterface } from '../../Auth/Interfaces/UserInterface';


const BASE_URL = '/users';

export const findAll = async() => {
  try {
 
      const response = await apiClient.get(BASE_URL);

      return response;
  } catch (error) {
      console.error("[UserService] Error en findAll:", error);
      throw error;
  }
}

export const findAllPages = async (page = 0, search = '') => {
  try {
 
    const response = await apiClient.get(`${BASE_URL}/page/${page}`, {
      params: {
        search,
      },
    });

    return response;
  } catch (error) {
    console.error("[UserService] Error en findAllPages:", error);
    throw error;
  }
};
  

export const save = async (user: UserInterface) => {
  const { trainerDetails, ...userData } = user;
  console.log("aqui los datos de usuario",userData);
  console.log("aqui los datos de trainer",trainerDetails);
  
  const response = await apiClient.post(BASE_URL, {
    ...userData,
    ...(trainerDetails ? trainerDetails : {}),
  });
  console.log("AQUI ESTA LA RESPUESTA",response);

  return response;
};

  
  export const update = async ({ id, username, email, admin, trainer }: UserInterface) => {
    return await apiClient.put(`${BASE_URL}/${id}`, { username, email, admin, trainer });
  };
  


export const remove = async (id: string) => {
    await apiClient.delete(`${BASE_URL}/${id}`);
};

export * from './users/usersSlice';// src/Admin/store/users/usersSlice.ts

import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { UserInterface } from "../../../Auth/Interfaces/UserInterface";

// Define la interfaz para la paginación
interface Paginator {
  number: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

// Define la interfaz para un usuario y el estado inicial
export const initialUserForm: UserInterface = {
  id: "",
  username: '',
  password: '',
  email: '',
  admin: false,
  trainer: false,
  role: "",
  roles: []
};

const initialErrors = {
  username: '',
  password: '',
  email: '',
};

const initialState = {
  users: [] as UserInterface[],
  paginator: { number: 0, totalPages: 1, first: true, last: false } as Paginator,
  userSelected: initialUserForm,
  visibleForm: false,
  errors: initialErrors,
  isLoading: true,
};

// Crear el slice de usuarios
export const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    addUser: (state, action: PayloadAction<UserInterface>) => {
      state.users = [
        ...state.users,
        {
          ...action.payload,
        }
      ];
      state.userSelected = initialUserForm;
      state.visibleForm = false;
    },
    removeUser: (state, action: PayloadAction<string>) => { 
      state.users = state.users.filter(user => user.id !== action.payload);
    },
    updateUser: (state, action: PayloadAction<UserInterface>) => {
      state.users = state.users.map(u => {
        if (u.id === action.payload.id) {
          return {
            ...action.payload,
          };
        }
        return u;
      });
      state.userSelected = initialUserForm;
      state.visibleForm = false;
    },
    loadingUsers: (state, action: PayloadAction<UserInterface[]>) => {
      state.users = action.payload;
      state.isLoading = false;
    },
    updatePaginator: (state, action: PayloadAction<Paginator>) => {
      state.paginator = action.payload;
    },
    onUserSelectedForm: (state, action: PayloadAction<UserInterface>) => {
      state.userSelected = action.payload;
      state.visibleForm = true;
    },
    onOpenForm: (state) => {
      state.visibleForm = true;
    },
    onCloseForm: (state) => {
      state.visibleForm = false;
      state.userSelected = initialUserForm;
    },
    loadingError: (state, action: PayloadAction<Partial<typeof initialErrors>>) => {
      state.errors = { ...state.errors, ...action.payload };
    }
  }
});

export const {
  addUser,
  removeUser,
  updateUser,
  loadingUsers,
  onUserSelectedForm,
  onOpenForm,
  onCloseForm,
  loadingError,
  updatePaginator,
} = usersSlice.actions;

export default usersSlice.reducer;
// src/api/apiClient.ts

import axios from 'axios';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
});

// Interceptor para agregar el token de autenticación en cada solicitud
apiClient.interceptors.request.use(
  (config) => {
    const token = sessionStorage.getItem('token');

    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    return config;
  },
  (error) => {
    console.error('[API Client] Error en la solicitud:', error);
    return Promise.reject(error);
  }
);

export default apiClient;
// src/Auth/hooks/useAuth.ts

import { useNavigate } from 'react-router-dom';
import Swal from 'sweetalert2';
import { loginUser } from '../services/authService';
import { useDispatch, useSelector } from 'react-redux';
import { onLogin, onLogout, updateProfile } from '../store/auth/authSlice';

import { RootState } from '../../store';
import { AxiosError } from 'axios';
import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import apiClient from '../../Apis/apiConfig';
import { LoginCredentials } from '../Interfaces/AuthInterface';
export const useAuth = () => {
  const dispatch = useDispatch();
  const { user, isAdmin, trainer, isAuth, roles, token } = useSelector(
    (state: RootState) => state.auth
  );
  const navigate = useNavigate();

  // Handler para el login
  const handlerLogin = async (
    { email, password }: LoginCredentials,
    from?: string // Agregamos el parámetro 'from' opcional
  ) => {
    try {
      const response = await loginUser({ email, password });


      const token = response?.data?.token;
    if (!token) {
      throw new Error("No se recibió token en la respuesta.");
    }

      console.log("aqui el token",token);
      const claims = JSON.parse(window.atob(token.split(".")[1]));
      console.log("aqui los claims",claims);


      // Extraer roles
      let rolesArray: string[] = [];

if (claims.authorities) {
  let authorities = claims.authorities;
  // Si es un string JSON, parsear.
  if (typeof authorities === 'string') {
    try {
      authorities = JSON.parse(authorities);
    } catch (e) {
      authorities = [];
    }
  }
  // Filtrar a strings
  if (Array.isArray(authorities)) {
    rolesArray = authorities.map((r: any) => (typeof r === 'string' ? r : ''));
  }
}

const user: UserInterface = {
  id: claims.id || 0,
  username: claims.username || '',
  email: claims.sub || email,
  admin: claims.isAdmin || false,
  trainer: claims.isTrainer || false,
  // <-- ¡AQUÍ!: roles como array de strings
  roles: rolesArray,
  profileImageUrl: claims.profileImageUrl || '',
};
      console.log("aqui el usuario",user);
      if (user.trainer) {
        console.log("AQUI EDELGARD entro al if user.trainer ",user);
        try {
          const trainerResponse = await apiClient.get(`/trainers/findByUserId/${user.id}`);
          console.log("aca deberia cambiarle el id",trainerResponse);
          const trainerData = trainerResponse.data;
          console.log("Trainer encontrado:", trainerData);
      
          user.id = trainerData.id;
      
          // ACTUALIZA EL TRAINER ID EN REDUX
          dispatch(updateProfile({
            ...user,
            id: trainerData.id  
          }));
        } catch (error) {
          console.error("Error obteniendo trainerId:", error);
        }
      }
      



      dispatch(onLogin({
        user,
        roles: rolesArray,
        isAdmin: user.admin,
        trainer: user.trainer,
        token
      }));
  
      // Guardar en sessionStorage
      sessionStorage.setItem('login', JSON.stringify({
        isAuth: true,
        isAdmin: user.admin,
        trainer: user.trainer,
        user,
        roles: rolesArray,
      }));
      sessionStorage.setItem('token', `${token}`);
  

      // Redirigir al usuario según 'from' o su rol
      if (from) {
        navigate(from);
      } else if (user.admin) {
        console.log("Navegando a /admin/dashboard para admin");
        navigate('/admin/dashboard');
      } else if (user.trainer) {
        console.log("Navegando a /trainers para entrenador");
        navigate('/trainers/dashboard');
      } else {
        console.log("Navegando a /dashboard para usuarios regulares");
        navigate('/dashboard');
      }
      

    } catch (error: unknown) {
      console.error("Error en el login:", error);
      const axiosError = error as AxiosError;
      if (axiosError.response?.status === 401) {
        Swal.fire('Error de inicio de sesión', 'Correo o contraseña incorrectos', 'error');
      } else if (axiosError.response?.status === 403) {
        Swal.fire('Acceso denegado', 'No tiene permisos para acceder', 'error');
      } else {
        Swal.fire('Error inesperado', axiosError.message, 'error');
      }
    }
  };

  // Handler para el logout
  const handlerLogout = () => {
    dispatch(onLogout());
    sessionStorage.removeItem('token');
    sessionStorage.removeItem('login');
    sessionStorage.clear();
    navigate('/auth/login');
  };

  return {
    login: {
      user,
      isAdmin,
      trainer,
      isAuth,
      roles,
      token,
    },
    handlerLogin,
    handlerLogout,
  };
}; 


export interface LoginCredentials {
    password: string;
    email: string;
}
import { UserInterface } from "../../Auth/Interfaces/UserInterface";


export interface AuthState {
  status: 'checking' | 'authenticated' | 'not-authenticated';
  user: UserInterface | null;
  isAuth: boolean;
  isAdmin: boolean;
  trainer?: boolean;
  roles: string[]; 
  token: string | null;
  profileImageUrl?: string; 
  errorMessage?: string;
}

// src/interfaces/UserInterface.ts

// src/interfaces/UserInterface.ts

export interface Role {
  authority: string;
}

export interface TrainerDetails {
  specialization?: string;
  experienceYears?: number;
  availability?: boolean;
  monthlyFee?: number;
  title?: string;
  studies?: string;
  certifications?: string;
  description?: string;
  instagramUrl?: string;
  whatsappNumber?: string;
}

export interface UserInterface {
  id: number;
  username: string;
  password?: string;
  email: string;
  admin: boolean;
  trainer?: boolean;
  role?: Role | string;
  roles?: string[];
  profileImageUrl?: string;
  trainerDetails?: TrainerDetails;
    certificationFile?: File;
}







export * from './Login/LoginPage';
export * from './Register/RegisterPage';// src/Auth/pages/Login/LoginPage.tsx

import { useFormik } from 'formik';
import * as Yup from 'yup';
import { useAuth } from '../../hooks/useAuth';
import { Link, useLocation } from 'react-router-dom';
import './LoginPage.css';

export const LoginPage = () => {
  const { handlerLogin } = useAuth();
  const location = useLocation();

  // Obtenemos la ruta de origen, si existe
  const from = location.state?.from || null;

  const formik = useFormik({
    initialValues: {
      loginEmail: '',
      loginPassword: '',
    },
    validationSchema: Yup.object({
      loginEmail: Yup.string()
        .email('Correo electrónico no válido')
        .required('Requerido'),
      loginPassword: Yup.string()
        .min(6, 'La contraseña debe tener al menos 6 caracteres')
        .required('Requerido'),
    }),
    onSubmit: async (values) => {
      await handlerLogin(
        {
          email: values.loginEmail,
          password: values.loginPassword,
        },
        from // Pasamos 'from' a 'handlerLogin'
      );
    },
  });

  return (
    <div className="container login-container">
      <div className="row">
        <div className="col-md-6 login-form-1">
          <h3>Ingreso</h3>
          <form onSubmit={formik.handleSubmit}>
            <div className="form-group mb-2">
              <input
                type="text"
                className={`form-control ${formik.touched.loginEmail && formik.errors.loginEmail ? 'is-invalid' : ''
                  }`}
                placeholder="Correo"
                {...formik.getFieldProps('loginEmail')}
              />
              {formik.touched.loginEmail && formik.errors.loginEmail && (
                <div className="invalid-feedback">{formik.errors.loginEmail}</div>
              )}
            </div>

            <div className="form-group mb-2">
              <input
                type="password"
                className={`form-control ${formik.touched.loginPassword && formik.errors.loginPassword ? 'is-invalid' : ''
                  }`}
                placeholder="Contraseña"
                {...formik.getFieldProps('loginPassword')}
              />
              {formik.touched.loginPassword && formik.errors.loginPassword && (
                <div className="invalid-feedback">{formik.errors.loginPassword}</div>
              )}
            </div>

            <div className="d-grid gap-2">
              <input
                type="submit"
                className="btnSubmit"
                value="Login"
              />
            </div>
            <div className="form-group mt-2 text-center">
              <span>¿No tienes una cuenta? </span>
              <Link to="/auth/register">Regístrate aquí</Link>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};
/* Centrado de contenedor en la pantalla */
.login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh; /* Ocupar toda la altura de la pantalla */
}

.row {
    width: 100%;
    display: flex;
    justify-content: center; /* Centra el contenido dentro de la fila */
}

.login-form-1 {
    width: 100%;
    max-width: 400px; /* Limita el ancho máximo del formulario */
    border-radius: 5px;
    box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2), 0 9px 26px 0 rgba(0, 0, 0, 0.19);
    padding: 20px;
    background-color: #ffffff;
}

.login-form-1 h3 {
    text-align: center;
    color: #333;
}

.login-container form {
    padding: 10px;
}

.btnSubmit {
    border-radius: 1rem;
    padding: 10px;
    border: none;
    cursor: pointer;
    margin: 10px 0;
}

.login-form-1 .btnSubmit {
    color: #fff;
    background-color: #0062cc;
}

.form-group {
    margin-bottom: 15px;
}

/* Estilo del enlace de "Regístrate" */
.link {
    color: #0062cc;
    font-weight: bold;
    text-decoration: none;
}

.link:hover {
    text-decoration: underline;
}
import { useFormik } from 'formik';
import * as Yup from 'yup';
import { Link, useNavigate } from 'react-router-dom';
import Swal from 'sweetalert2';
import './RegisterPage.css';
import { registerUser } from '../../services/authService';

export const RegistrationPage = () => {
    const navigate = useNavigate();

    const formik = useFormik({
        initialValues: {
            username: '',
            email: '',
            password: '',
            confirmPassword: '',
        },
        validationSchema: Yup.object({
            username: Yup.string()
                .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
                .required('Requerido'),
            email: Yup.string()
                .email('Correo electrónico no válido')
                .required('Requerido'),
            password: Yup.string()
                .min(6, 'La contraseña debe tener al menos 6 caracteres')
                .required('Requerido'),
            // Puedes agregar validación para confirmPassword si lo necesitas
        }),
        onSubmit: async (values) => {
            try {
                await registerUser({
                    username: values.username,
                    email: values.email,
                    password: values.password,
                });

                // Si el registro fue exitoso mostramos el mensaje y redirigimos
                Swal.fire({
                    icon: 'success',
                    title: 'Registro exitoso',
                    text: 'Tu cuenta ha sido creada correctamente.',
                    confirmButtonText: 'Continuar'
                }).then(() => {
                    navigate('/auth/login');
                });
            } catch (error: any) {
                // Si el backend envía un mensaje específico, se captura y muestra
                if (error.response && error.response.data && error.response.data.message) {
                    const errorMessage: string = error.response.data.message;
                    // Validación para correo duplicado
                    if(errorMessage === 'El correo electrónico ya está en uso'){
                        Swal.fire({
                            icon: 'error',
                            title: 'Correo ya registrado',
                            text: 'El correo electrónico que ingresaste ya está en uso. Por favor, usa otro correo.'
                        });
                    } else if(errorMessage === 'El nombre de usuario ya está en uso'){
                        Swal.fire({
                            icon: 'error',
                            title: 'Nombre de usuario en uso',
                            text: 'El nombre de usuario que ingresaste ya está en uso. Por favor, escoge otro.'
                        });
                    } else {
                        // Si es otro error, mostramos el mensaje devuelto por el backend
                        Swal.fire({
                            icon: 'error',
                            title: 'Error al registrar',
                            text: errorMessage,
                        });
                    }
                } else {
                    // En caso de error inesperado sin estructura definida
                    Swal.fire({
                        icon: 'error',
                        title: 'Error inesperado',
                        text: 'Ocurrió un error, por favor intenta nuevamente.'
                    });
                }
            }
        }
    });

    return (
        <div className="container login-container">
            <div className="row">
                <div className="col-md-6 login-form-1">
                    <h3>Registro</h3>
                    <form onSubmit={formik.handleSubmit}>
                        <div className="form-group mb-2">
                            <input
                                type="text"
                                className={`form-control ${formik.touched.username && formik.errors.username ? 'is-invalid' : ''}`}
                                placeholder="Nombre de usuario"
                                {...formik.getFieldProps('username')}
                            />
                            {formik.touched.username && formik.errors.username && (
                                <div className="invalid-feedback">{formik.errors.username}</div>
                            )}
                        </div>

                        <div className="form-group mb-2">
                            <input
                                type="email"
                                className={`form-control ${formik.touched.email && formik.errors.email ? 'is-invalid' : ''}`}
                                placeholder="Correo electrónico"
                                {...formik.getFieldProps('email')}
                            />
                            {formik.touched.email && formik.errors.email && (
                                <div className="invalid-feedback">{formik.errors.email}</div>
                            )}
                        </div>

                        <div className="form-group mb-2">
                            <input
                                type="password"
                                className={`form-control ${formik.touched.password && formik.errors.password ? 'is-invalid' : ''}`}
                                placeholder="Contraseña"
                                {...formik.getFieldProps('password')}
                            />
                            {formik.touched.password && formik.errors.password && (
                                <div className="invalid-feedback">{formik.errors.password}</div>
                            )}
                        </div>

                        {/* Aquí podrías agregar el input de confirmPassword si lo requieres */}

                        <div className="d-grid gap-2">
                            <input
                                type="submit"
                                className="btnSubmit"
                                value="Registrar"
                            />
                        </div>
                        <div className="form-group mt-2 text-center">
                            <span>¿Ya tienes una cuenta? </span>
                            <Link to="/auth/login">Inicia sesión aquí</Link>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    );
};
// src/Auth/pages/Register/RegistrationPageRedirect.tsx

import { Navigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../../../store';
import { RegistrationPage } from '../Register/RegisterPage';

const RegistrationPageRedirect = () => {
  const { isAuth } = useSelector((state: RootState) => state.auth);
  return isAuth ? <Navigate to="/admin/users" /> : <RegistrationPage />;
};

export default RegistrationPageRedirect;
/* Estilo general del contenedor */
.register-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh; /* Ocupar toda la altura de la pantalla */
}

/* Estructura general del formulario */
.register-form-2 {
    width: 100%;
    max-width: 450px; /* Limita el ancho máximo del formulario */
    border-radius: 5px;
    box-shadow: 0 5px 8px 0 rgba(0, 0, 0, 0.2), 0 9px 26px 0 rgba(0, 0, 0, 0.19);
    padding: 30px;
    background-color: #ffffff;
}

/* Título del formulario */
.register-form-2 h3 {
    text-align: center;
    color: #333;
    margin-bottom: 20px;
}

/* Estilo de los inputs dentro del formulario */
.register-form-2 .form-group input {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    width: 100%;
    transition: border 0.3s ease;
}

/* Efecto hover en los inputs */
.register-form-2 .form-group input:focus {
    border: 1px solid #0062cc;
    outline: none;
}

/* Estilo general de los botones */
.btnSubmit {
    border-radius: 1rem;
    padding: 10px;
    border: none;
    cursor: pointer;
    margin: 10px 0;
}

/* Botón para registrar */
.register-form-2 .btnSubmit {
    color: #fff;
    background-color: #28a745; /* Verde para diferenciar del login */
}

/* Estilo de los grupos de formulario */
.form-group {
    margin-bottom: 15px;
}

/* Contenido adicional (links, textos) */
.register-container form {
    padding: 10px;
}

/* Estilo para los enlaces */
.link {
    color: #0062cc;
    font-weight: bold;
    text-decoration: none;
}

.link:hover {
    text-decoration: underline;
}

/* Estilo para mensajes de error */
.error-message {
    color: #ff4d4d;
    font-size: 0.9em;
    margin-top: -10px;
    margin-bottom: 10px;
    text-align: left;
}
/* Agrupación del input y el ícono */
.input-group {
    position: relative; /* Esto asegura que el ícono se posicione dentro del contenedor del input */
    display: flex;
    align-items: center;
}

/* Alineación del ícono de ojo dentro del campo de contraseña */
.input-group .input-group-text {
    position: absolute; /* El ícono se posiciona absolutamente dentro del contenedor relativo */
    right: 10px; /* Margen derecho para el ícono */
    top: 50%; /* Coloca el ícono en el centro vertical del input */
    transform: translateY(-50%); /* Ajusta la posición vertical al centro exacto */
    background-color: transparent; /* Elimina cualquier fondo por defecto del ícono */
    border: none; /* Sin borde */
    cursor: pointer; /* El cursor cambia al puntero cuando se pasa sobre el ícono */
    font-size: 1.2rem; /* Tamaño del ícono */
}

/* Aumentar el padding del input para evitar que el texto se superponga con el ícono */
.input-group input {
    padding-right: 40px; /* Espacio suficiente para el ícono */
}

/* Mantener el estilo del input cuando está enfocado */
.input-group input:focus {
    border-color: #0062cc; /* Color del borde al enfocar */
    outline: none;
}

// src/services/authService.ts

import axios from 'axios';
import apiClient from '../../Apis/apiConfig';
import { LoginCredentials } from '../Interfaces/AuthInterface';


export const loginUser = async ({ email, password }: LoginCredentials) => {
  try {
    console.log(
      "entro");
    const response = await apiClient.post('/login', { email, password });

    return response;
  } catch (error) {
    handleApiError(error);
  }
};

export const registerUser = async (userData: {
  username: string;
  email: string;
  password: string;
}) => {
  try {

    const response = await axios.post('http://localhost:8080/users/register', userData, {
      headers: {
        'Content-Type': 'application/json',
      },
    });
  
    return response.data;
  } catch (error) {
    handleApiError(error);
  }
};

// Función para manejar errores
const handleApiError = (error: unknown) => {
  if (axios.isAxiosError(error)) {
    // Retiras el throw de new Error y simplemente relanzas el error original
    throw error; 
  }
  // Si no es un AxiosError, aquí lanzas algo genérico
  throw new Error('Ocurrió un error desconocido.');
};



export * from './auth/authSlice';
// src/store/auth/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AuthState } from '../../Interfaces/AuthState';
import { UserInterface } from '../../../Auth/Interfaces/UserInterface';



const initialState: AuthState = {
  status: 'not-authenticated',
  user: null,
  isAuth: false,
  isAdmin: false,
  trainer: false,
  roles: [],
  token: null,
  errorMessage: undefined,
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    onChecking: (state) => {
      state.status = 'checking';
      state.user = null;
      state.isAuth = false;
      state.isAdmin = false;
      state.trainer = false;
      state.roles = [];
      state.errorMessage = undefined;
    },
    onLogin: (state, { payload }) => {
      state.status = 'authenticated';
      state.user = payload.user;
      state.isAuth = true;
      state.isAdmin = payload.isAdmin;
      state.trainer = payload.trainer;
      state.roles = payload.roles;
      state.token = payload.token; // Agrega esta línea
      state.errorMessage = undefined;
    },
    onLogout: (state) => {
      state.status = 'not-authenticated';
      state.user = null;
      state.isAuth = false;
      state.isAdmin = false;
      state.trainer = false;
      state.roles = [];
      state.errorMessage = undefined;
    },
    clearErrorMessage: (state) => {
      state.errorMessage = undefined;
    },
    updateProfile: (state, { payload }: PayloadAction<UserInterface>) => {
      if (state.user && state.user.id === payload.id) {
        state.user = payload;
        state.isAdmin = payload.admin;
        state.trainer = payload.trainer;
        state.roles = payload.roles || [];
      } else {
        // Asegura que cualquier actualización de trainer se refleje
        state.user = payload;
        state.trainer = payload.trainer;
      }
    },
  },
});

export const { onChecking, onLogin, onLogout, clearErrorMessage, updateProfile } = authSlice.actions;
export default authSlice.reducer;
// src/components/LoadingSpinner.tsx
import { Box, CircularProgress, Typography } from '@mui/material';
import { keyframes } from '@emotion/react';
import styled from '@emotion/styled';

const pulse = keyframes`
  0% { transform: scale(0.95); opacity: 0.6; }
  50% { transform: scale(1); opacity: 1; }
  100% { transform: scale(0.95); opacity: 0.6; }
`;

const AnimatedBox = styled(Box)`
  animation: ${pulse} 1.5s ease-in-out infinite;
`;

const LoadingSpinner = () => {
  return (
    <Box
      display="flex"
      flexDirection="column"
      alignItems="center"
      justifyContent="center"
      minHeight="100vh"
      sx={{
        background: 'linear-gradient(45deg, #f3f4f6 30%, #e5e7eb 90%)',
      }}
    >
      <AnimatedBox>
        <CircularProgress 
          size={80}
          thickness={4}
          sx={{
            color: (theme) => theme.palette.primary.main,
            marginBottom: 2,
          }}
        />
      </AnimatedBox>
      <Typography 
        variant="h6" 
        color="textSecondary"
        sx={{
          fontFamily: 'Roboto, sans-serif',
          fontWeight: 500,
          letterSpacing: '0.05em',
        }}
      >
        Cargando contenido...
      </Typography>
    </Box>
  );
};

export default LoadingSpinner;import React, { useEffect, useState } from 'react';
import { Swiper, SwiperSlide } from 'swiper/react';
import { Pagination } from 'swiper/modules';
import { Navigation } from 'swiper/modules';
import { Autoplay } from 'swiper/modules';

import 'swiper/css';
import 'swiper/css/pagination';
import 'swiper/css/navigation';

import { getCarouselImages } from '../../services/getCarouselImages';
import './Carousel.css';

interface Image {
  id: number;
  imageUrl: string;
  caption: string;
  orderNumber: number;
}

const Carousel = () => {
  const [images, setImages] = useState<Image[]>([]);

  useEffect(() => {
    const fetchImages = async () => {
      try {
        const data = await getCarouselImages();
        console.log('Datos recibidos del backend:', data);
        setImages(data);
      } catch (error) {
        console.error('Error al obtener imágenes del carrusel:', error);
      }
    };

    fetchImages();
  }, []);

  return (
    <Swiper
      modules={[Pagination, Navigation, Autoplay]}
      spaceBetween={50}
      slidesPerView={1}
      pagination={{ clickable: true }}
      navigation
      autoplay={{ delay: 6000 }}
    >
      {images.length > 0 ? (
  images.map((image) => (
    <SwiperSlide key={image.id}>
      {!image.imageUrl ? (
        <div style={{ width: '100%', height: '200px', backgroundColor: '#ccc' }}>
          {/* Placeholder */}
        </div>
      ) : (
        <img className="carousel-image" src={image.imageUrl} alt={image.caption} />
      )}
    </SwiperSlide>
  ))
) : (
  <p>No hay imágenes disponibles.</p>
)}

    </Swiper>
  );
};

export default Carousel;
// src/components/common/SearchBar.tsx
import React from 'react';

interface SearchBarProps {
  placeholder?: string;
  value: string;
  onChange: (value: string) => void;
}

const SearchBar: React.FC<SearchBarProps> = ({ placeholder = 'Buscar...', value, onChange }) => {
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onChange(event.target.value);
  };

  return (
    <input
      type="text"
      placeholder={placeholder}
      value={value}
      onChange={handleChange}
      style={{ padding: '8px', width: '100%', marginBottom: '16px' }}
    />
  );
};

export default SearchBar;
.carousel-image {
  width: 100%;
  height: 500px;
  object-fit: contain;  /* Cambiar de cover a contain */
}

  
  .swiper-slide {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  // src/components/layout/MainLayout.tsx

import React, { Suspense } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';

import Header from './Header/Header';
import Footer from './Footer/Footer';
import Sidebar from './SideBar/SideBar';
import { PROTECTED_PATHS } from '../../config/protectedPaths';
import Carousel from '../common/Carousel';
import LoadingSpinner from '../LoadingSpinner';

const MainLayout = () => {
  console.log('MainLayout montado');
  const { isAuth, user } = useSelector((state: RootState) => state.auth);

  // Detectar la ruta actual
  const location = useLocation();
  const currentPath = location.pathname.toLowerCase();

  // Roles del usuario
  const userRoles = user?.roles?.map((r) =>
    typeof r === 'string' ? r : r.authority
  ) || [];

  // Verificamos si es una ruta protegida (para mostrar/u ocultar sidebar)
  const isProtectedRoute = PROTECTED_PATHS.some((protectedPath) =>
    currentPath.startsWith(protectedPath.toLowerCase())
  );

  const canSeeSidebar =
    isAuth &&
    isProtectedRoute &&
    (userRoles.includes('ROLE_ADMIN') ||
      userRoles.includes('ROLE_TRAINER') ||
      userRoles.includes('ROLE_USER'));

  // Verificamos si la ruta es la Home ("/")
  const isHomePage = currentPath === '/';

  return (
    <>
      <Header />
      {isHomePage && <Carousel />}
      
      <div style={{ display: 'flex', minHeight: '80vh' }}>
        {canSeeSidebar && <Sidebar />}
        
        <div style={{ flex: 1, padding: isHomePage ? 0 : '1rem' }}>
          <Suspense fallback={<LoadingSpinner />}>
            <Outlet />
          </Suspense>
        </div>
      </div>

      {!isProtectedRoute && <Footer />}
    </>
  );
};

export default MainLayout;
// src/components/layout/ProtectedLayout.tsx
import { Outlet } from 'react-router-dom';
import { Box, Toolbar } from '@mui/material';
import Navbar from '../../components/layout/NavBar/NavBar';
import Sidebar from '../../components/layout/SideBar/SideBar';


const ProtectedLayout = () => {
  return (
    <Box sx={{ display: 'flex' }}>
      
      <Navbar />

      <Sidebar />
      <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
        <Toolbar />
        <Outlet />
      </Box>
    </Box>
  );
};

export default ProtectedLayout;
// src/components/layout/PublicLayout.tsx

import { Outlet } from 'react-router-dom';
import Header from '../layout/Header/Header';
import Footer from '../layout/Footer/Footer';

const PublicLayout = () => {
  return (
    <>
      <Header />
      <main>
        <Outlet />
      </main>
      <Footer />
    </>
  );
};

export default PublicLayout;
// Footer.tsx
import React, { useEffect, useState } from 'react';
import './Footer.css';
import { FaInstagram, FaFacebookF, FaWhatsapp, FaTwitter } from 'react-icons/fa';
import { getGymInfo } from '../../../Admin/services/gymInfoService';
import { GymInfoValues } from '../../../Admin/pages/GymInfoForm';

const Footer = () => {
  const [gymInfo, setGymInfo] = useState<GymInfoValues | null>(null);

  useEffect(() => {
    const fetchGymData = async () => {
      try {
        const data = await getGymInfo();
        console.log("aqui la data del gym",data);
        setGymInfo(data);
      } catch (error) {
        console.error('Error fetching gym info:', error);
      }
    };
    
    fetchGymData();
  }, []);

  // Mientras se carga la info, se puede mostrar un loading o usar valores por defecto
  const defaultGymInfo: GymInfoValues = {
    gymName: 'Nuestro Gimnasio',
    address: 'Dirección no disponible',
    phone: '',
    email: '',
    instagram: '',
    facebook: '',
    whatsapp: '',
    twitter: ''
  };

  const info = gymInfo || defaultGymInfo;

  return (
    <footer className="footer-container">
      <div className="footer-content">
        <div className="footer-section about">
          <h2>{info.gymName}</h2>
          <p>{info.address ? `📍 ${info.address}` : 'Entrena con los mejores equipos y profesionales'}</p>
        </div>
        
        <div className="footer-section contact">
          <h3>Contacto</h3>
          {info.phone && <p><strong>Teléfono:</strong> {info.phone}</p>}
          {info.email && (
            <p>
              <strong>Email:</strong>{' '}
              <a href={`mailto:${info.email}`} style={{ color: 'white' }}>
                {info.email}
              </a>
            </p>
          )}
        </div>

        <div className="footer-section social">
          <h3>Síguenos</h3>
          <div className="social-links">
            {info.instagram && (
              <a href={info.instagram} target="_blank" rel="noopener noreferrer">
                <FaInstagram /> Instagram
              </a>
            )}
            
            {info.facebook && (
              <a href={info.facebook} target="_blank" rel="noopener noreferrer">
                <FaFacebookF /> Facebook
              </a>
            )}
            
            {info.whatsapp && (
              <a href={info.whatsapp} target="_blank" rel="noopener noreferrer">
                <FaWhatsapp /> WhatsApp
              </a>
            )}
            
            {info.twitter && (
              <a href={info.twitter} target="_blank" rel="noopener noreferrer">
                <FaTwitter /> Twitter
              </a>
            )}
          </div>
        </div>
      </div>
      
      <div className="footer-bottom">
        <p>
          © {new Date().getFullYear()} {info.gymName}. Todos los derechos reservados.
        </p>
      </div>
    </footer>
  );
};

export default Footer;
.footer-container {
    background-color: #000;
    color: white;
    padding: 40px 0;
    text-align: center;
    width: 100%;
    margin: 0;
  }
  
  .footer-content {
    display: flex;
    justify-content: space-evenly;
    flex-wrap: wrap;
  }
  
  .footer-bottom {
    border-top: 1px solid #444;
    padding-top: 20px;
    margin: 0;
  }
  // src/components/layout/Header/Header.tsx

import React, { useState, useEffect, MouseEvent } from 'react';
import {
  AppBar, Toolbar, Typography, Button, Box, Menu, MenuItem,
  IconButton, Badge
} from '@mui/material';
import { styled } from '@mui/system';
import FitnessCenterIcon from '@mui/icons-material/FitnessCenter';
import DashboardIcon from '@mui/icons-material/Dashboard';
import { Link as RouterLink, useNavigate } from 'react-router-dom';

import { useSelector } from 'react-redux';
import { RootState } from '../../../store';
import { useAuth } from '../../../Auth/hooks/useAuth';

import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
import { getAllCategories, Category } from '../../../Store/services/CategoryService';

const NavButton = styled(Button)(({ theme }) => ({
  color: '#ffffff',
  margin: theme.spacing(1),
  transition: 'transform 0.3s, backgroundColor 0.3s',
  fontSize: '1rem',
  '&:hover': {
    backgroundColor: '#f50057',
    transform: 'scale(1.1)',
  },
}));

// Ruta base del front (p.ej. "/") y nav items para usuarios no autenticados:
const publicNavItems = [
  { label: 'Inicio', path: '/' },
  { label: 'Nosotros', path: '/about' },
  { label: 'Servicios', path: '/services' },
  { label: 'Contacto', path: '/contact' },
];

function getDashboardPath(roles: string[]): string {
  if (roles.includes('ROLE_ADMIN')) return '/admin/dashboard';
  if (roles.includes('ROLE_TRAINER')) return '/trainers/dashboard';
  // Por defecto, un user normal
  return '/dashboard';
}

const Header: React.FC = () => {
  const navigate = useNavigate();
  const { login, handlerLogout } = useAuth();

  // Roles del usuario
  const userRoles = login.user?.roles?.map(r => 
    typeof r === 'string' ? r : r.authority
  ) || [];

  // Carrito
  const cartItems = useSelector((state: RootState) => state.cart.items);
  const totalItems = cartItems.reduce((sum, item) => sum + item.quantity, 0);

  // Categorías tienda
  const [categories, setCategories] = useState<Category[]>([]);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [anchorElCart, setAnchorElCart] = useState<null | HTMLElement>(null);

  // Cargar las categorías
  useEffect(() => {
    const load = async () => {
      try {
        const c = await getAllCategories();
        setCategories(c);
      } catch (error) {
        console.error('Error al cargar categorías', error);
      }
    };
    load();
  }, []);

  // Menú de tienda
  const handleStoreMenuOpen = (e: MouseEvent<HTMLElement>) => {
    setAnchorEl(e.currentTarget);
  };
  const handleStoreMenuClose = () => {
    setAnchorEl(null);
  };

  // Carrito
  const handleCartClick = (e: MouseEvent<HTMLElement>) => {
    setAnchorElCart(e.currentTarget);
  };
  const handleCartClose = () => {
    setAnchorElCart(null);
  };

  // Navegación
  const handleNavigate = (path: string) => {
    navigate(path);
    handleStoreMenuClose();
  };

  // Botón para ir al dashboard según rol
  const goToDashboard = () => {
    const dashPath = getDashboardPath(userRoles);
    navigate(dashPath);
  };

  return (
    <AppBar position="static" color="primary">
      <Toolbar>
        {/* Logo */}
        <FitnessCenterIcon sx={{ display: { xs: 'none', sm: 'block' }, mr: 1 }} />
        <Typography
          variant="h6"
          component={RouterLink}
          to="/"
          sx={{
            textDecoration: 'none',
            color: '#ffffff',
            flexGrow: 1,
            display: { xs: 'none', sm: 'block' },
            fontWeight: 'bold',
          }}
        >
          GymPro
        </Typography>

        {/* Menú principal (solo para no autenticados o para todos) */}
        <Box sx={{ display: 'flex', justifyContent: 'center', flexGrow: 1 }}>
          {publicNavItems.map((item) => (
            <NavButton
              key={item.label}
              component={RouterLink}
              to={item.path}
            >
              {item.label}
            </NavButton>
          ))}

          {/* Tienda (desplegable) */}
          <NavButton onClick={handleStoreMenuOpen}>Tienda</NavButton>
          <Menu
            anchorEl={anchorEl}
            open={Boolean(anchorEl)}
            onClose={handleStoreMenuClose}
          >
            <MenuItem onClick={() => handleNavigate('/store')}>
              Ver Todos
            </MenuItem>
            {categories.map((cat) => (
              <MenuItem
                key={cat.id}
                onClick={() => handleNavigate(`/store?category=${cat.name}`)}
              >
                {cat.name}
              </MenuItem>
            ))}
          </Menu>
        </Box>

        {/* Carrito */}
        <IconButton sx={{ color: '#ffffff' }} onClick={handleCartClick}>
          <Badge badgeContent={totalItems} color="error">
            <ShoppingCartIcon />
          </Badge>
        </IconButton>
        <Menu
          anchorEl={anchorElCart}
          open={Boolean(anchorElCart)}
          onClose={handleCartClose}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          transformOrigin={{ vertical: 'top', horizontal: 'right' }}
        >
          <Box sx={{ p: 2, minWidth: 300 }}>
            {cartItems.length === 0 ? (
              <Typography>No hay productos en el carrito</Typography>
            ) : (
              <>
                {cartItems.map((item) => (
                  <Box
                    key={item.product.id}
                    display="flex"
                    justifyContent="space-between"
                    alignItems="center"
                    mb={2}
                  >
                    <Box display="flex" alignItems="center">
                      <img
                        src={item.product.imageUrl}
                        alt={item.product.name}
                        style={{
                          width: 60, height: 60, objectFit: 'cover',
                          marginRight: 12, borderRadius: 8
                        }}
                      />
                      <Box>
                        <Typography variant="body2">{item.product.name}</Typography>
                        <Typography variant="body2">
                          Cantidad: {item.quantity}
                        </Typography>
                      </Box>
                    </Box>
                    <Typography variant="body2" sx={{ ml: 2 }}>
                      ${item.product.price * item.quantity}
                    </Typography>
                  </Box>
                ))}
                <Box mt={2}>
                  <Button
                    variant="contained"
                    fullWidth
                    onClick={() => {
                      handleCartClose();
                      navigate('/cart');
                    }}
                  >
                    Ver Carrito
                  </Button>
                </Box>
              </>
            )}
          </Box>
        </Menu>

        {/* Aquí el bloque de autenticación */}
        {login.isAuth ? (
          <>
            {/* Botón "Ir a mi Dashboard" */}
            <IconButton sx={{ color: '#ffffff', ml: 1 }} onClick={goToDashboard}>
              <DashboardIcon />
            </IconButton>
            {/* Nombre de usuario (opcional) */}
            <Typography sx={{ ml: 2, mr: 2 }}>
              Hola, {login.user?.username}
            </Typography>
            {/* Botón cerrar sesión */}
            <Button color="inherit" onClick={handlerLogout}>
              Cerrar Sesión
            </Button>
          </>
        ) : (
          <>
            <Button
              color="inherit"
              component={RouterLink}
              to="/auth/login"
            >
              Iniciar Sesión
            </Button>
            <Button
              color="inherit"
              component={RouterLink}
              to="/auth/register"
            >
              Registrarse
            </Button>
          </>
        )}
      </Toolbar>
    </AppBar>
  );
};

export default Header;
import React from 'react';
import { AppBar, Toolbar, Typography, IconButton, Button } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuth } from '../../../Auth/hooks/useAuth';

const Navbar: React.FC = () => {
  const { login, handlerLogout } = useAuth();

  return (
    <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
      <Toolbar>
        {/* Botón para abrir el menú lateral en dispositivos móviles (opcional) */}
        <IconButton
          color="inherit"
          aria-label="open drawer"
          edge="start"
          sx={{ mr: 2, display: { sm: 'none' } }}
        >
          <MenuIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          GymApp
        </Typography>
        
        {login.isAuth && login.user && (
          <Typography variant="body1" sx={{ marginRight: 2 }}>
            {`Hola, ${login.user.username}`}
          </Typography>
        )}

        {login.isAuth && (
          <Button color="inherit" onClick={handlerLogout}>
            Cerrar Sesión
          </Button>
        )}
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;
// src/components/layout/SideBar/SideBar.tsx

import React, { useState } from 'react';
import { useAuth } from '../../../Auth/hooks/useAuth';
import { useNavigate } from 'react-router-dom';
import {
  Drawer,
  Toolbar,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  Collapse,
} from '@mui/material';
import { ExpandLess, ExpandMore } from '@mui/icons-material';
import { menuItems } from '../../../config/menuItems';


// Ancho del drawer
const drawerWidth = 300;

const Sidebar: React.FC = () => {
  const { login } = useAuth();
  const navigate = useNavigate();
  
  // Rol principal del usuario (admin, trainer o user)
  const userRoles = login.roles || [];
  // Si asumimos que userRoles siempre tendrá 1 rol, lo tomamos:
  const userRole = userRoles.length > 0 ? userRoles[0] : 'ROLE_USER';


  // Estado para controlar qué submenú está abierto
  const [openSubmenu, setOpenSubmenu] = useState<string | null>(null);

  const handleClickItem = (label: string) => {
    // Si el submenú que se clickeó ya está abierto, lo cerramos
    if (openSubmenu === label) {
      setOpenSubmenu(null);
    } else {
      // Si está cerrado (o hay otro abierto), abrimos este
      setOpenSubmenu(label);
    }
  };

  return (
    <Drawer
      variant="permanent"
      sx={{
        width: drawerWidth,
        
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: drawerWidth,
          boxSizing: 'border-box',
          // Ejemplo de gradiente de fondo y color de texto blanco
          background: 'linear-gradient(45deg, #2196F3 30%, #F44336 90%)',
          color: '#fff',
        },
      }}
    >
      <Toolbar />
      <Divider />

      <List>
        {menuItems
          .filter((item) => item.roles.includes(userRole))
          .map((item) => {
            // Si el item tiene subItems, renderizamos un menú colapsable
            if (item.subItems && item.subItems.length > 0) {
              return (
                <React.Fragment key={item.label}>
                  <ListItemButton onClick={() => handleClickItem(item.label)}>
                    <ListItemIcon sx={{ color: '#fff' }}>
                      {React.createElement(item.icon)}
                    </ListItemIcon>
                    <ListItemText primary={item.label} />
                    {openSubmenu === item.label ? <ExpandLess /> : <ExpandMore />}
                  </ListItemButton>

                  <Collapse in={openSubmenu === item.label} timeout="auto" unmountOnExit>
                    <List component="div" disablePadding>
                      {item.subItems.map((sub) => (
                        <ListItemButton
                          key={sub.label}
                          sx={{ pl: 8 }} // un poco de padding para sub-items
                          onClick={() => navigate(sub.path)}
                        >
                          <ListItemText primary={sub.label} />
                        </ListItemButton>
                      ))}
                    </List>
                  </Collapse>
                </React.Fragment>
              );
            } 
            // Si el item NO tiene subItems, renderizamos un item simple
            else {
              return (
                <ListItemButton
                  key={item.label}
                  onClick={() => navigate(item.path)}
                >
                  <ListItemIcon sx={{ color: '#fff' }}>
                    {React.createElement(item.icon)}
                  </ListItemIcon>
                  <ListItemText primary={item.label} />
                </ListItemButton>
              );
            }
          })}
      </List>
    </Drawer>
  );
};

export default Sidebar;
// src/components/Calendar/TrainerCalendar.tsx
import React, { useEffect, useState } from 'react';
import { Calendar, dateFnsLocalizer, SlotInfo, Event } from 'react-big-calendar';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import { format, parse, startOfWeek, getDay, startOfDay } from 'date-fns';
import { enUS, es } from 'date-fns/locale';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import apiClient from '../../Apis/apiConfig';
import { Button, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Snackbar, Alert, CircularProgress } from '@mui/material';
import { getWeeklySlots, bookSlot } from '../../services/calendarService/CalendarService';
import { format as formatDate } from 'date-fns';

// Definición de locales para React Big Calendar
const locales = {
  'en-US': enUS,
  'es': es,
};

const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek: () => startOfWeek(new Date(), { weekStartsOn: 1 }), 
  getDay,
  locales,
});

// Booking Interface
interface Booking {
  id: number;
  startDateTime: string;
}

// TimeSlot Interface
interface TimeSlot {
  trainerId: number;
  startDateTime: string; // ISO string
  endDateTime: string;   // ISO string
  available: boolean;
}

// CalendarEvent extiende Event y agrega slotId
interface CalendarEvent extends Event {
  slotId: string;
}

const TrainerCalendar: React.FC = () => {
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [selectedSlot, setSelectedSlot] = useState<SlotInfo | null>(null);
  const [openDialog, setOpenDialog] = useState(false);
  const [bookingStatus, setBookingStatus] = useState<{
    open: boolean;
    severity: 'success' | 'error';
    message: string;
  }>({
    open: false,
    severity: 'success',
    message: '',
  });

  const [trainerId, setTrainerId] = useState<number | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [existingBooking, setExistingBooking] = useState<Booking | null>(null);

  // Del store
  const email = useSelector((state: RootState) => state.auth.user?.email);
  const token = useSelector((state: RootState) => state.auth.token);

  // Interceptor con token
  useEffect(() => {
    console.log("Aqui calendario usuario")
    if (token) {
      apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      console.log("[useEffect - token] Token actualizado:", token);
    }
  }, [token]);

  // Función para obtener los slots
  const fetchTimeSlots = async (trainerId: number) => {
    console.log("[fetchTimeSlots] Iniciando fetch de slots para trainerId:", trainerId);
    try {
      const timeSlots: TimeSlot[] = await getWeeklySlots(trainerId);
      console.log("[fetchTimeSlots] timeSlots desde backend:", timeSlots);

      // Filtrar solo los 'available'
      const availableSlots = timeSlots.filter(slot => slot.available);
      console.log("[fetchTimeSlots] availableSlots:", availableSlots);

      // Mapeo a formato BigCalendar
      const calendarEvents: CalendarEvent[] = availableSlots.map(slot => ({
        title: 'Disponible',
        start: new Date(slot.startDateTime),
        end: new Date(slot.endDateTime),
        allDay: false,
        slotId: slot.startDateTime
      }));
      console.log("[fetchTimeSlots] calendarEvents generados:", calendarEvents);

      setEvents(calendarEvents);
      setLoading(false);
    } catch (err) {
      console.error('Error al obtener los slots:', err);
      setError('No se pudieron obtener los horarios disponibles.');
      setLoading(false);
    }
  };

  // Cargar trainerId y slots cuando se monta
  useEffect(() => {
    const fetchTrainerId = async () => {
      try {
        const response = await apiClient.get('/users/personal-trainer');
        console.log("Trainer Data:", response.data);
        setTrainerId(response.data.id);
        return response.data.id;
      } catch (err) {
        console.error('Error al obtener el entrenador personal:', err);
        setError('No se pudo obtener el entrenador personal asignado.');
        return null;
      }
    };

    const initializeCalendar = async () => {
      console.log("[initializeCalendar] Iniciando carga del calendario para email:", email);
      if (email) {
        const fetchedTrainerId = await fetchTrainerId();
        console.log("aqui fetchedTrainerId",fetchedTrainerId);
        if (fetchedTrainerId) {
          await fetchTimeSlots(fetchedTrainerId);
        } else {
          setLoading(false);
        }
      } else {
        setLoading(false);
      }
    };

    initializeCalendar();
  }, [email]);

  // Al hacer clic en un event (slot disponible)
  const handleSelectEvent = async (event: CalendarEvent) => {
    console.log("Al hacer clic en un event (slot disponible)");
    const slotInfo: SlotInfo = {
      start: event.start,
      end: event.end,
      slots: [event.start],
      action: 'select',
    };
    setSelectedSlot(slotInfo);

    try {
      // Se usa startOfDay solo para verificar si ya existe reserva ese día
      // (Dependiendo de tu backend, ajusta según la lógica)
      const slotStartFormatted = formatDate(startOfDay(slotInfo.start), "yyyy-MM-dd'T'HH:mm:ss");
      console.log("slotStartFormatted",slotStartFormatted);

      const response = await apiClient.get(`/trainer-schedule/${trainerId}/existing-booking`, {
        params: { slotStart: slotStartFormatted },
      });

      console.log("[handleSelectEvent] existing-booking response:", response);

      const existing = response.data;
      console.log("existing",existing);

      setExistingBooking(existing || null);
    } catch (err) {
      console.error('Error al verificar reserva existente:', err);
      setExistingBooking(null);
    }

    setOpenDialog(true);
  };

  // Al hacer clic en un slot vacío
  const handleSelectSlot = (slotInfo: SlotInfo) => {
    console.log("Al hacer clic en un slot vacío");
    setBookingStatus({
      open: true,
      severity: 'error',
      message: 'Este horario no está disponible para reserva.',
    });
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    setSelectedSlot(null);
  };

  // Confirmar reserva
  const handleConfirmBooking = async () => {
    console.log("Confirmar reserva");
    if (selectedSlot && trainerId) {
        try {
            const localSlotStart = format(selectedSlot.start, "yyyy-MM-dd'T'HH:mm:ss");
            console.log("AQUI localSlotStart ", localSlotStart);

            // Verificar si ya existe una reserva
            const response = await apiClient.get(`/trainer-schedule/${trainerId}/existing-booking`, {
                params: { slotStart: localSlotStart },
            });
            console.log("Verificar si existe una reserva", response);

            const existingBooking = response.data;

            if (existingBooking) {
                const confirmModification = window.confirm(
                    `Ya tienes una reserva el ${new Date(existingBooking.startDateTime).toLocaleDateString()}
                     a las ${new Date(existingBooking.startDateTime).toLocaleTimeString()}. 
                     ¿Quieres modificarla por este horario?`
                );

                if (!confirmModification) return;

                await apiClient.delete(`/trainer-schedule/cancel-booking/${existingBooking.id}`);

                const bookingResponse = await bookSlot(trainerId, localSlotStart);

                if (bookingResponse.status === 200) {
                    await fetchTimeSlots(trainerId);
                    setBookingStatus({
                        open: true,
                        severity: 'success',
                        message: 'Reserva modificada con éxito.',
                    });
                }
            } else {
                const bookingResponse = await bookSlot(trainerId, localSlotStart);
                if (bookingResponse.status === 200) {
                    await fetchTimeSlots(trainerId);
                    setBookingStatus({
                        open: true,
                        severity: 'success',
                        message: 'Reserva realizada con éxito.',
                    });
                }
            }
        } catch (error: any) {
            console.error('Error al reservar el slot:', error);
            const errorMessage =
                error.response?.data?.message ||
                error.response?.data?.error ||
                'Error desconocido al reservar el horario';

            setBookingStatus({
                open: true,
                severity: 'error',
                message: errorMessage,
            });
        } finally {
            handleCloseDialog();
        }
    }
};


  const handleCloseSnackbar = () => {
    setBookingStatus(prev => ({ ...prev, open: false }));
  };

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', marginTop: '20px' }}>
        <CircularProgress />
      </div>
    );
  }

  if (error) {
    return (
      <Alert severity="error" style={{ marginTop: '20px' }}>
        {error}
      </Alert>
    );
  }

  return (
    <div>
      <h2>Calendario de Entrenador Personal</h2>

      {trainerId ? (
        <Calendar
        key={location.key}
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: 600 }}
        selectable
        onSelectSlot={handleSelectSlot}
        onSelectEvent={handleSelectEvent}
        views={['week']}             // Solo mostramos la vista de semana
        defaultView="week"           // Vista por defecto 'week'
        popup
          eventPropGetter={() => ({
            style: {
              backgroundColor: 'green',
              color: 'white',
            },
          })}
        />
      ) : (
        <Alert severity="warning">
          No tienes un entrenador personal asignado.
        </Alert>
      )}

      {/* Diálogo de Confirmación */}
      <Dialog open={openDialog} onClose={handleCloseDialog}>
        <DialogTitle>Confirmar Reserva</DialogTitle>
        <DialogContent>
          {existingBooking ? (
            <DialogContentText>
              Ya tienes una reserva el <strong>{new Date(existingBooking.startDateTime).toLocaleDateString()}</strong> 
              a las <strong>{new Date(existingBooking.startDateTime).toLocaleTimeString()}</strong>.
              ¿Quieres modificarla por este horario?
            </DialogContentText>
          ) : (
            <DialogContentText>
              ¿Estás seguro de que deseas reservar este horario?
            </DialogContentText>
          )}
          {selectedSlot && (
            <div>
              <p><strong>Fecha:</strong> {selectedSlot.start.toLocaleDateString()}</p>
              <p><strong>Hora:</strong> 
                {selectedSlot.start.toLocaleTimeString()} - {selectedSlot.end.toLocaleTimeString()}
              </p>
            </div>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog} color="secondary">
            Cancelar
          </Button>
          <Button onClick={handleConfirmBooking} color="primary">
            Confirmar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar */}
      <Snackbar
        open={bookingStatus.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
      >
        <Alert
          onClose={handleCloseSnackbar}
          severity={bookingStatus.severity}
          sx={{ width: '100%' }}
        >
          {bookingStatus.message}
        </Alert>
      </Snackbar>
    </div>
  );
};

export default TrainerCalendar;
// src/config/menuItems.ts

import React from 'react';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import AssignmentIndIcon from '@mui/icons-material/AssignmentInd';
import PhotoLibraryIcon from '@mui/icons-material/PhotoLibrary';
import AccountCircleIcon from '@mui/icons-material/AccountCircle';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday'; 
import EventIcon from '@mui/icons-material/Event';
import FitnessCenterIcon from '@mui/icons-material/FitnessCenter';
import MedicalInformationIcon from '@mui/icons-material/MedicalInformation';
import MeasurementsIcon from '@mui/icons-material/FitnessCenter';
import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
import AssignmentIcon from '@mui/icons-material/Assignment';
import InfoIcon from '@mui/icons-material/Info';


export interface MenuItem {
  label: string;
  path: string;
  icon: React.ElementType;
  roles: string[];
  subItems?: {
    label: string;
    path: string;
    roles: string[];
  }[];
}

export const menuItems: MenuItem[] = [
  {
    label: 'Dashboard Admin',
    path: '/admin/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Dashboard User',
    path: '/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Sesiones Personal Trainer',
    path: '/dashboard/trainer-sessions',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Reservar horario personal trainer',
    path: '/trainers/my-calendar',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  },
  {
    label: 'Usuarios',
    path: '/admin/users/page/0',
    icon: PeopleIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Dashboard Trainer',
    path: '/trainers/dashboard',
    icon: DashboardIcon,
    roles: ['ROLE_TRAINER'],
  },
  {
    label: 'Planes',
    path: '#', // Para activar el dropdown
    icon: AssignmentIcon,
    roles: ['ROLE_ADMIN'],
    subItems: [
      {
        label: 'Gestión de planes',
        path: '/admin/plans',
        roles: ['ROLE_ADMIN'],
      },
      {
        label: 'Facturas de planes',
        path: '/admin/planes/page/0',
        roles: ['ROLE_ADMIN'],
      },
    ],
  },
  {
    label: 'Administrador de Carrusel',
    path: '/admin/carousel',
    icon: PhotoLibraryIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Editar Perfil',
    path: '/trainers/edit-profile',
    icon: AccountCircleIcon,
    roles: ['ROLE_TRAINER', 'ROLE_USER'],
  },
  {

    label: 'Productos',
    path: '#',
    icon: ShoppingCartIcon,
    roles: ['ROLE_ADMIN'],
    subItems: [
      {
        label: 'Gestión de productos',
        path: '/admin/store/products',
        roles: ['ROLE_ADMIN'],
      },
      {
        label: 'Facturas de productos',
        path: '/admin/facturas/page/0',
        roles: ['ROLE_ADMIN'],
      },
    ],
  },
  {
    label: 'Gestión de Categorías',
    path: '/admin/store/categories',
    icon: ShoppingCartIcon,
    roles: ['ROLE_ADMIN'],
  },
  /*
  {
    label: 'Calendario',
    path: '/dashboard/calendar',
    icon: CalendarTodayIcon,
    roles: ['ROLE_USER'],
  }, */
  {
    label: 'Asignar Disponibilidad',
    path: '/admin/trainer-availability',
    icon: EventIcon,
    roles: ['ROLE_ADMIN'],
  },
  {
    label: 'Agregar Medición',
    path: '/trainers/clients/:clientId/measurements/add',
    icon: MedicalInformationIcon,
    roles: ['ROLE_TRAINER'],
  },
  /*
  {
    label: 'Agregar Rutina',
    path: '/trainers/clients/1/routines/add',
    icon: FitnessCenterIcon,
    roles: ['ROLE_TRAINER'],
  }, */
  {
    label: 'Mediciones',
    path: '/users/measurements',
    icon: MeasurementsIcon,
    roles: ['ROLE_USER'],
  },
  /*
  {
    label: 'Clases Grupales',
    path: '/admin/group-classes/create',
    icon: FitnessCenterIcon,
    roles: ['ROLE_ADMIN'],
  }, */
  /*
  {
    label: 'Asignar Entrenador a Clase',
    path: '/admin/group-classes/assign-trainer',
    icon: AssignmentIndIcon,
    roles: ['ROLE_ADMIN'],
  }, */
  /*
  {
    label: 'Clases Disponibles',
    path: '/users/group-classes/available',
    icon: FitnessCenterIcon,
    roles: ['ROLE_USER'],
  }, */


  // ⚠️ Antes estaba “Facturas” suelto, lo eliminamos para agruparlo en “Productos”:
  // {
  //   label: 'Facturas',
  //   path: '/admin/facturas/page/0',
  //   icon: ReceiptIcon,
  //   roles: ['ROLE_ADMIN'],
  // },

  // Este “Planes” al final parece duplicado, podrías borrarlo si ya manejaste planes arriba
  // {
  //   label: 'Planes',
  //   path: '/admin/planes/page/0',
  //   icon: AssignmentIcon,
  //   roles: ['ROLE_ADMIN'],
  // },

  // Tienes un submenú de tienda para usuarios y trainers
  {
    label: 'Tienda',
    path: '/store',
    icon: ShoppingCartIcon,
    roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
    subItems: [
      {
        label: 'Proteína',
        path: '/store/proteina',
        roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
      },
      {
        label: 'Creatina',
        path: '/store/creatina',
        roles: ['ROLE_USER', 'ROLE_ADMIN', 'ROLE_TRAINER'],
      },
    ],
  },

  {
    label: 'Gym Info',
    path: '/admin/gym-info',
    icon: InfoIcon,
    roles: ['ROLE_ADMIN'],
  },
];
export const PROTECTED_PATHS = [
  '/dashboard',
  '/admin/dashboard',
  '/admin/users',
  '/trainers',
  '/admin/carousel',
  '/dashboard/calendar',
  '/admin/trainer-availability',
  '/trainers/clients',
  '/users/measurements',
  '/admin/group-classes',
  '/store/cart',
  '/auth/login',  
    '/admin/store/products',  
    '/admin/store/products/page',
  '/admin/store/categories',
  '/admin/plans',
  '/admin/planes',
  '/admin/facturas',
  '/admin/gym-info',
];


export const getPrimaryRole = (roles: string[]): string => {
    const rolePriority = ['ROLE_ADMIN', 'ROLE_TRAINER', 'ROLE_USER']; // Jerarquía de roles
    for (const role of rolePriority) {
        if (roles.includes(role)) {
            console.log("aqui el rol", role);
            return role;
          }
          
    }
    return 'ROLE_USER'; // Rol predeterminado si no se encuentra otro
  };
  
  // src/Store/hooks/useCategories.ts
import { useState, useEffect } from 'react';
import { getAllCategories } from '../Store/services/CategoryService';
import { Category } from '../Store/services/CategoryService';

export const useCategories = () => {
  const [categories, setCategories] = useState<Category[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchCategories = async () => {
    setLoading(true);
    try {
      const data = await getAllCategories();
      setCategories(data);
    } catch (err) {
      setError('Error al cargar categorías');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  return { categories, loading, error };
};
import { useEffect, useState } from 'react';

/**
 * Recibe un string con la fecha/hora de fin de oferta (ej: "2025-01-31T23:59:59")
 * Retorna la cadena de texto con "Xh Ym Zs" restante, o "¡Terminó!" si ya llegó a 0.
 */
export function useCountdown(discountEnd: string | undefined) {
  const [timeLeft, setTimeLeft] = useState('');

  useEffect(() => {
    if (!discountEnd) {
      setTimeLeft('');
      return;
    }

    const endDate = new Date(discountEnd).getTime();

    function updateCountdown() {
      const now = new Date().getTime();
      const diff = endDate - now;

      if (diff <= 0) {
        setTimeLeft('¡Terminó!');
        return;
      }

      // Calculamos horas, minutos y segundos
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      setTimeLeft(`${hours}h ${minutes}m ${seconds}s`);
    }

    // Lanzamos la actualización de inmediato
    updateCountdown();

    // Actualizamos cada segundo
    const timer = setInterval(updateCountdown, 1000);
    return () => clearInterval(timer);
  }, [discountEnd]);

  return timeLeft;
}
// src/Store/hooks/useProducts.ts
import { useEffect, useState } from 'react';
import { Product } from '../Store/interface/Product';
import {
  advancedSearchProducts,
  getDistinctBrands,
  getProductsBySearch,
  getDistinctFlavors,
} from '../Store/services/ProductService';

interface PaginatorState {
  totalPages: number;
  number: number;
  first: boolean;
  last: boolean;
}

interface UseProductsProps {
  searchTerm: string;
  category: string | null;
  pageNumber: number;
}

interface UseProductsReturn {
  products: Product[];
  paginator: PaginatorState;
  loading: boolean;
  sortBy: string;
  setSortBy: React.Dispatch<React.SetStateAction<string>>;
  checkBoxInStock: boolean;
  setCheckBoxInStock: React.Dispatch<React.SetStateAction<boolean>>;
  selectedBrands: string[];
  setSelectedBrands: React.Dispatch<React.SetStateAction<string[]>>;
  selectedFlavors: string[];
  setSelectedFlavors: React.Dispatch<React.SetStateAction<string[]>>;
  priceRange: number[];
  setPriceRange: React.Dispatch<React.SetStateAction<number[]>>;
  brands: string[];
  flavors: string[];     
}

export const useProducts = ({
  searchTerm,
  category,
  pageNumber,
}: UseProductsProps): UseProductsReturn => {
  // Estados internos del hook
  const [products, setProducts] = useState<Product[]>([]);
  const [paginator, setPaginator] = useState<PaginatorState>({
    totalPages: 0,
    number: 0,
    first: true,
    last: false,
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [brands, setBrands] = useState<string[]>([]);
  const [flavors, setFlavors] = useState<string[]>([]);   

  // Estados para ordenamiento y filtros
  const [sortBy, setSortBy] = useState<string>('price_asc');
  const [checkBoxInStock, setCheckBoxInStock] = useState<boolean>(false);
  const [selectedBrands, setSelectedBrands] = useState<string[]>([]);
  const [selectedFlavors, setSelectedFlavors] = useState<string[]>([]);
  const [priceRange, setPriceRange] = useState<number[]>([0, 100000]);

  const isSearching = searchTerm.trim() !== '';

  useEffect(() => {
    const fetchProductsAndFilters = async () => {
      setLoading(true);
      try {
        // 1) Obtener Marcas únicas
        const brandsResponse = await getDistinctBrands();
        setBrands(brandsResponse);

        // 2) Obtener Sabores únicos <-- Aquí
        const flavorsResponse = await getDistinctFlavors();
        setFlavors(flavorsResponse);

        // 3) Cargar productos
        if (isSearching) {
          // Buscar en backend por nombre, o traer todo y filtrar:
          const foundProducts = await getProductsBySearch(searchTerm);
          setProducts(foundProducts);
          // Reiniciar paginador
          setPaginator({ totalPages: 0, number: 0, first: true, last: true });
        } else {
          // Filtros combinados
          const filters = {
            category: category || null,
            inStock: checkBoxInStock ? true : undefined,
            brands: selectedBrands,
            flavors: selectedFlavors,   // <-- Añade los sabores seleccionados
            minPrice: priceRange[0],
            maxPrice: priceRange[1],
          };

          // Llamada avanzada con paginación
          const response = await advancedSearchProducts({
            page: pageNumber,
            size: 12,
            sortBy,
            ...filters,
          });

          setProducts(response.content);
          setPaginator({
            totalPages: response.totalPages,
            number: response.number,
            first: response.first,
            last: response.last,
          });
        }

      } catch (error) {
        console.error('Error al cargar productos:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchProductsAndFilters();
  }, [
    isSearching,
    searchTerm,
    category,
    pageNumber,
    sortBy,
    checkBoxInStock,
    selectedBrands,
    selectedFlavors,
    priceRange,
  ]);

  return {
    products,
    paginator,
    loading,
    sortBy,
    setSortBy,
    checkBoxInStock,
    setCheckBoxInStock,
    selectedBrands,
    setSelectedBrands,
    selectedFlavors,
    setSelectedFlavors,
    priceRange,
    setPriceRange,
    brands,
    flavors, 
  };
};

export interface LoginCredentials {
    password: string;
    email: string;
}
// UserInterface.ts
export interface UserState {
    id?: string;
    username: string;
    password: string;
    email: string;
    admin: boolean;
    trainer: boolean;
      // Agregar la propiedad 'role'
    role: string;
    // O si manejas roles como un array:
    roles: string[];
    // Otros campos...
    profileImageUrl: string;
}
const AboutUsPage = () => {
    return (
      
        <h1>Aquí está el AboutUsPage</h1>
     
    );
  };
  
  export default AboutUsPage;
const ContactPage = () => {
    return (
      
        <h1>Aquí está el HomePage</h1>
     
    );
  };
  
  export default ContactPage;
  import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

// Swiper
import { Swiper, SwiperSlide } from 'swiper/react';
import { Pagination, Navigation } from 'swiper/modules';
import 'swiper/css';
import 'swiper/css/pagination';
import 'swiper/css/navigation';

// Tus imágenes locales
import './HomePage.css';
import img1 from '../../assets/Equipamiento.png';
import img2 from '../../assets/Clases_grupales.png';
import img3 from '../../assets/Personal_Trainer.png';
import img4 from '../../assets/Suplementos.png';
import planImg from '../../assets/t600x362.jpg';
import renuevaImg from '../../assets/smart-fit.jpg';
import semaforoImg from '../../assets/entrenador-personal-madrid.jpg';
import gratisImg from '../../assets/reserva.png';
import { Product } from '../../Store/interface/Product';
// Importamos la función que obtiene los productos en oferta
import { getDiscountedProducts } from '../../services/DiscountedProductsService';


// Función auxiliar para calcular precio final y descuento
function getDiscountedPrice(product: Product) {
  const now = new Date();
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;

  let isDiscountActive = false;
  if (
    product.discountPercent > 0 &&
    start && end &&
    now >= start &&
    now <= end
  ) {
    isDiscountActive = true;
  }

  const originalPrice = product.price;
  let finalPrice = product.price;
  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return {
    originalPrice,
    finalPrice,
    isDiscountActive,
    discountReason: isDiscountActive ? product.discountReason : null,
  };
}

const HomePage = () => {
  const navigate = useNavigate();
  const [discountedProducts, setDiscountedProducts] = useState<Product[]>([]);

  // Cargar productos en oferta cuando se monta el componente
  useEffect(() => {
    const fetchDiscountedProducts = async () => {
      try {
        const data = await getDiscountedProducts();
        setDiscountedProducts(data);
      } catch (error) {
        console.error(error);
      }
    };
    fetchDiscountedProducts();
  }, []);

  // Función para navegar según la tarjeta clicada
  const handleFeatureClick = (feature: 'clubes' | 'grupales' | 'planes' | 'tienda') => {
    switch (feature) {
      case 'clubes':
        navigate('/about');
        break;
      case 'grupales':
        navigate('/services');
        break;
      case 'planes':
        navigate('/services');
        break;
      case 'tienda':
        navigate('/store');
        break;
      default:
        break;
    }
  };

  // Nuevo handler al hacer clic en la card de producto
  const handleProductClick = (productId: number) => {
    navigate(`/store/product/${productId}`);
  };

  return (
    <div className="homepage-container">
      <h1>Bienvenido al Gimnasio</h1>

      {/* SECCIÓN DE FEATURES */}
      <div className="features-container">
        <div className="feature-item" onClick={() => handleFeatureClick('clubes')}>
          <img src={img1} alt="Clubes full equipados" />
          <p>CLUBES FULL EQUIPADOS</p>
        </div>
        <div className="feature-item" onClick={() => handleFeatureClick('grupales')}>
          <img src={img2} alt="Clases grupales" />
          <p>CLASES GRUPALES</p>
        </div>
        <div className="feature-item" onClick={() => handleFeatureClick('planes')}>
          <img src={img3} alt="Personal trainer" />
          <p>PLANES DE GIMNASIO + PERSONAL TRAINER</p>
        </div>
        <div className="feature-item" onClick={() => handleFeatureClick('tienda')}>
          <img src={img4} alt="Medicina deportiva" />
          <p>TIENDA DE SUPLEMENTOS</p>
        </div>
      </div>

      {/* SECCIÓN PROMO */}
      <div className="promo-section">
        <h2>SOMOS LOS QUE ENTRENAMOS CON TODO Y CON TOD@S</h2>
        <div className="promo-grid">
          <div className="promo-item">
            <img src={planImg} alt="Planes de gimnasio" />
            <p>PLANES DE GIMNASIO</p>
          </div>
          <div className="promo-item">
            <img src={renuevaImg} alt="Renueva tu plan" />
            <p>OBTEN DESCUENTOS EN SUPLEMENTOS</p>
          </div>
          <div className="promo-item">
            <img src={semaforoImg} alt="Semáforo nutricional" />
            <p>ESCOGE A TU PERSONAL TRAINER</p>
          </div>
          <div className="promo-item">
            <img src={gratisImg} alt="5 días gratis" />
            <p>RESERVA TU HORARIO DE ENTRENAMIENTO</p>
          </div>
        </div>
      </div>

      {/* CARRUSEL DE PRODUCTOS EN OFERTA */}
      <div style={{ margin: '40px auto', maxWidth: '1200px' }}>
        <h2>Productos en Oferta</h2>
        {discountedProducts.length === 0 ? (
          <p>No hay productos en oferta disponibles.</p>
        ) : (
          <Swiper
            modules={[Navigation, Pagination]}
            slidesPerView={3}
            spaceBetween={20}
            navigation
            pagination={{ clickable: true }}
          >
            {discountedProducts.map((product) => {
              const {
                originalPrice,
                finalPrice,
                isDiscountActive,
                discountReason,
              } = getDiscountedPrice(product);

              return (
                <SwiperSlide key={product.id}>
                  <div 
                    className="discount-product-card"
                    onClick={() => handleProductClick(product.id)}
                  >
                    <img
                      src={product.imageUrl}
                      alt={product.name}
                      className="discount-product-image"
                    />
                    <h3 className="discount-product-name">{product.name}</h3>

                    {isDiscountActive ? (
                      <div className="discount-product-price-section">
                        <p className="original-price">
                          <s>${originalPrice.toFixed(2)}</s>
                        </p>
                        <p className="final-price">${finalPrice.toFixed(2)}</p>
                        {discountReason && (
                          <p className="discount-reason">({discountReason})</p>
                        )}
                      </div>
                    ) : (
                      <div className="discount-product-price-section">
                        <p className="no-discount-price">
                          ${originalPrice.toFixed(2)}
                        </p>
                      </div>
                    )}
                  </div>
                </SwiperSlide>
              );
            })}
          </Swiper>
        )}
      </div>
    </div>
  );
};

export default HomePage;
.homepage-container {
  text-align: center;
  background: linear-gradient(135deg, #1976d2, #1565c0);
  color: white;
  padding: 50px 0;
  margin: 0;
  width: 100%;
  box-sizing: border-box;
  font-family: 'Arial', sans-serif;
}

.features-container {
  display: flex;
  justify-content: space-evenly;
  gap: 20px;
  flex-wrap: wrap;
  margin-top: 30px;
}

.feature-item {
  text-align: center;
  width: 160px;
  cursor: pointer;
  transition: transform 0.3s, box-shadow 0.3s;
}

.feature-item img {
  width: 160px;
  height: 160px;
  border-radius: 50%;
  border: 5px solid #ffffff;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s, box-shadow 0.3s;
}

.feature-item img:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.feature-item p {
  margin-top: 10px;
  font-weight: bold;
  font-size: 14px;
  color: #f3f3f3;
  text-transform: uppercase;
}

.feature-item:hover {
  transform: scale(1.05);
}

.promo-section {
  text-align: center;
  margin: 50px 0;
  padding: 20px;
  background: linear-gradient(135deg, #1e88e5, #1565c0);
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.promo-section h2 {
  color: #f0f0f0;
  font-size: 24px;
  margin-bottom: 20px;
  text-shadow: 2px 2px rgba(0, 0, 0, 0.2);
}

.promo-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  width: 100%;
}

.promo-item {
  position: relative;
  overflow: hidden;
  width: 100%;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s, box-shadow 0.3s;
}

.promo-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 10px;
  transition: transform 0.3s;
}

.promo-item:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
}

.promo-item p {
  position: absolute;
  bottom: 20px;
  left: 20px;
  color: white;
  font-size: 18px;
  font-weight: bold;
  text-shadow: 2px 2px rgba(0, 0, 0, 0.5);
  background: rgba(0, 0, 0, 0.5);
  padding: 5px 10px;
  border-radius: 5px;
  transition: background 0.3s;
}

.promo-item:hover p {
  background: rgba(0, 0, 0, 0.8);
}

.discount-product-card {
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  color: #333;
  transition: box-shadow 0.3s;
}

.discount-product-card {
  width: 300px;         /* ancho fijo */
  height: 380px;        /* alto fijo */
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  color: #333;
  transition: box-shadow 0.3s;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  margin: 0 auto; 
}

.discount-product-card:hover {
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.discount-product-image {
  width: 100%;
  height: 180px;
  object-fit: contain; 
  border-radius: 6px;
  margin-bottom: 8px;
}


.discount-product-name {
  margin: 0;
  font-size: 1rem;
  font-weight: bold;
  color: #333;
}

.discount-product-price-section {
  margin-top: 8px;
}

.original-price {
  color: #999;
  font-size: 0.9rem;
}

.final-price {
  color: red;
  font-weight: bold;
  font-size: 1.1rem;
  margin: 0;
}

.discount-reason {
  font-size: 0.9rem;
  font-style: italic;
  color: #e53935;
  margin: 0;
}

.no-discount-price {
  font-size: 1.1rem;
  color: #222;
  font-weight: bold;
  margin: 0;
}

.swiper-button-next, .swiper-button-prev {
  color: white !important; 
  font-size: 24px !important;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7); 
}

.swiper-button-next:hover, .swiper-button-prev:hover {
  transform: scale(1.2); 
}


import React, { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  CardActions,
  CardMedia,
  Button,
  Backdrop,
  CircularProgress,
  Chip
} from '@mui/material';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import { useNavigate, useLocation } from 'react-router-dom';
import apiClient from '../../Apis/apiConfig';
import InstagramIcon from '@mui/icons-material/Instagram'; 
import WhatsAppIcon from '@mui/icons-material/WhatsApp';
import { Plan } from '../../Store/interface/Plan'
import { Trainer } from '../../Store/interface/Trainer';

// Interfaces

/*
interface Plan {
  id: number;
  name: string;
  description?: string;
  price: number;          // Este ya es el PRECIO TOTAL del período (ej: 150000 anual)
  discount?: number;      // Porcentaje de descuento
  discountReason?: string;
  durationMonths?: number; // Cantidad de meses, ej: 12
} */

const PersonalTrainerPage = () => {
  // Entrenadores
  const [trainers, setTrainers] = useState<Trainer[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // Para mostrar spinner al crear preferencia de pago
  const [paymentLoading, setPaymentLoading] = useState(false);

  // Plan seleccionado
  const [plan, setPlan] = useState<Plan | null>(null);

  // Leer parámetros de URL
  const [searchParams] = useSearchParams();
  const planId = searchParams.get('planId');
  const onlyTrainer = searchParams.get('onlyTrainer') === 'true';

  // Auth y navegación
  const { isAuth, token } = useSelector((state: RootState) => state.auth);
  const navigate = useNavigate();
  const location = useLocation();

 

  // 1. Cargar entrenadores y, si corresponde, cargar el plan
  useEffect(() => {
    const fetchTrainers = async () => {
      try {
        const response = await apiClient.get('/trainer-schedule/all-available');
        console.log("entrenadores disponibles response",response);
    
        setTrainers(response.data);
      } catch (error) {
        console.error('Error fetching trainers:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchTrainers();

    // Si no es "onlyTrainer" y sí hay un planId, traer el plan
    if (!onlyTrainer && planId) {
      const response = apiClient
        .get(`/plans/${planId}`)
        .then((res) => {
          console.log("response",response);
          setPlan(res.data);
        })
        .catch((err) => {
          console.error('Error fetching plan:', err);
        });
    }
  }, [planId, onlyTrainer]);

  // 2. Calcular precio total del plan (ya es el costo de TODO el período).
  //    Sólo aplicamos descuento si existe:
  const getPlanPriceFinal = () => {
    if (!plan) return 0;
    let finalPrice = plan.price; // precio TOTAL
    if (plan.discount && plan.discount > 0) {
      finalPrice = finalPrice - (finalPrice * (plan.discount / 100));
    }
    return finalPrice;
  };

  // 3. Al hacer clic en "Contratar Entrenador" o "Contratar Plan + Entrenador"
  const handleHireTrainer = async (trainerId: number) => {
    if (!isAuth) {
      alert('Por favor, inicia sesión para continuar.');
      // Guardar la ruta actual para redirigir tras login
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }

    if (!token) {
      alert('Token no encontrado. Por favor, inicia sesión nuevamente.');
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }

    // Construimos URL del endpoint
    let url = '/payment/create_plan_preference';
    if (onlyTrainer) {
      url += `?trainerId=${trainerId}&onlyTrainer=true`;
      console.log("url",url);
    } else {
      if (!planId) {
        alert('No se encontró el plan. Por favor, regresa y selecciona un plan.');
        navigate('/services');
        return;
      }
      url += `?planId=${planId}&trainerId=${trainerId}`;
      console.log("url",url);
    }

    setPaymentLoading(true); // Mostrar spinner
    try {
      const config = {
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      };

      const response = await apiClient.post(url, {}, config);
      console.log("response",response);
      const preference = response.data;

      // Redirigir a la URL de Mercado Pago
      window.location.href = preference.initPoint;
    } catch (error) {
      setPaymentLoading(false); // Ocultar spinner si hay error
      console.error('Error al crear la preferencia de pago:', error);
      alert('Ocurrió un error al procesar tu solicitud. Por favor, intenta nuevamente.');
    }
  };

  // 4. Mientras cargamos entrenadores, mostramos un mensaje
  if (loading) {
    return <Typography>Cargando entrenadores...</Typography>;
  }

  // 5. Obtener el precio final del plan (ya con descuento)
  const planPriceFinal = getPlanPriceFinal();

  return (
    <Box sx={{
      p: 4,
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      minHeight: '100vh'
    }}>
      <Backdrop open={paymentLoading} sx={{ color: '#fff', zIndex: 9999 }}>
        <CircularProgress color="inherit" size={80} thickness={4} />
      </Backdrop>

      <Typography variant="h3" gutterBottom align="center" sx={{
        fontFamily: 'Poppins, sans-serif',
        fontWeight: 700,
        color: '#2d3436',
        mb: 6,
        textTransform: 'uppercase',
        letterSpacing: 2
      }}>
        Elige tu Entrenador
      </Typography>

      {/* Sección de precio */}
      {!onlyTrainer && plan && (
        <Box sx={{
          textAlign: 'center',
          mb: 6,
          p: 3,
          borderRadius: 3,
          background: 'rgba(255,255,255,0.9)',
          boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
          maxWidth: 400,
          mx: 'auto'
        }}>
          {/* ... (contenido del precio se mantiene igual) */}
        </Box>
      )}


      <Grid container spacing={4}>
        {trainers.map((trainer) => {
          // Tarifa mensual del entrenador
          const monthlyFee = trainer.monthlyFee || 0;

          // SI QUIERES COBRAR 12 MESES DE ENTRENADOR (plan anual), puedes hacer:
          //   let trainerPrice = onlyTrainer ? monthlyFee : monthlyFee * (plan?.durationMonths ?? 1);
          // Pero si de momento sólo sumas "mes actual", dejas:
          const trainerPrice = onlyTrainer
            ? monthlyFee
            : monthlyFee * (plan?.durationMonths ?? 1);

          // Plan + Entrenador
          const total = plan ? planPriceFinal + trainerPrice : trainerPrice;

          return (
            <Grid item xs={12} sm={6} md={4} key={trainer.id}>
              <Card sx={{
                display: 'flex',
                flexDirection: 'column',
                height: '100%',
                borderRadius: 4,
                transition: 'all 0.3s ease',
                '&:hover': {
                  transform: 'translateY(-5px)',
                  boxShadow: '0 15px 35px rgba(0,0,0,0.15)'
                },
                background: 'rgba(255,255,255,0.95)'
              }}>
                <CardMedia
                  component="img"
                  height="280"
                  image={`${trainer.profileImageUrl}?v=${trainer.id}`}
                  alt={trainer.username}
                  sx={{
                    objectFit: 'cover',
                    borderTopLeftRadius: 16,
                    borderTopRightRadius: 16
                  }}
                />
                
                <CardContent sx={{ flexGrow: 1, px: 3, pt: 3 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h5" sx={{
                      fontFamily: 'Poppins',
                      fontWeight: 600,
                      color: '#2d3436',
                      flexGrow: 1
                    }}>
                      {trainer.username}
                    </Typography>
                    {trainer.title && (
                      <Chip
                        label={trainer.title}
                        size="small"
                        sx={{
                          bgcolor: '#0984e3',
                          color: 'white',
                          fontSize: '0.7rem',
                          height: 24
                        }}
                      />
                    )}
                  </Box>

                  <Typography variant="body2" sx={{
                    color: '#636e72',
                    mb: 2,
                    display: 'flex',
                    alignItems: 'center',
                    '& strong': { color: '#2d3436', mr: 1 }
                  }}>
                    🏋️♂️ <strong>Especialidad:</strong> {trainer.specialization}
                  </Typography>

                  {/* Redes Sociales */}
                  <Box sx={{ mb: 2 }}>
                    {trainer.instagramUrl && (
                      <Button
                        variant="outlined"
                        startIcon={<InstagramIcon />}
                        href={trainer.instagramUrl}
                        target="_blank"
                        sx={{
                          mr: 1,
                          color: '#e1306c',
                          borderColor: '#e1306c',
                          '&:hover': { bgcolor: '#fce4ec' }
                        }}
                      >
                        Instagram
                      </Button>
                    )}
                    
                    {trainer.whatsappNumber && (
                      <Button
                        variant="outlined"
                        startIcon={<WhatsAppIcon />}
                        href={`https://wa.me/${trainer.whatsappNumber}`}
                        target="_blank"
                        sx={{
                          color: '#25D366',
                          borderColor: '#25D366',
                          '&:hover': { bgcolor: '#e2f7eb' }
                        }}
                      >
                        WhatsApp
                      </Button>
                    )}
                  </Box>

                  {/* Certificación */}
                  {trainer.certificationFileUrl && (
                    <Button
                      variant="text"
                      size="small"
                      href={trainer.certificationFileUrl}
                      target="_blank"
                      sx={{
                        color: '#0984e3',
                        textTransform: 'none',
                        '&:hover': { textDecoration: 'underline' }
                      }}
                    >
                      📄 Ver Certificación
                    </Button>
                  )}

                  {/* Precios */}
                  <Box sx={{
                    mt: 3,
                    p: 2,
                    borderRadius: 2,
                    bgcolor: '#f8f9fa'
                  }}>
                    {onlyTrainer ? (
                      <Typography variant="body1" sx={{ fontWeight: 500 }}>
                        💸 Tarifa Mensual: 
                        <span style={{ color: '#00b894', marginLeft: 8 }}>
                          ${monthlyFee.toFixed(2)}
                        </span>
                      </Typography>
                    ) : (
                      <>
                        <Typography variant="body2" sx={{ color: '#636e72' }}>
                          Plan: <span style={{ color: '#00b894' }}>${planPriceFinal.toFixed(2)}</span>
                        </Typography>
                        <Typography variant="body2" sx={{ color: '#636e72', mb: 1 }}>
                          + Entrenador: <span style={{ color: '#00b894' }}>${trainerPrice.toFixed(2)}</span>
                        </Typography>
                        <Typography variant="h6" sx={{ 
                          color: '#2d3436',
                          fontWeight: 700,
                          textAlign: 'center'
                        }}>
                          🚀 Total: ${total.toFixed(2)}
                        </Typography>
                      </>
                    )}
                  </Box>
                </CardContent>

                <CardActions sx={{ p: 3, pt: 0 }}>
                  <Button
                    variant="contained"
                    fullWidth
                    onClick={() => handleHireTrainer(trainer.id)}
                    sx={{
                      bgcolor: '#00b894',
                      color: 'white',
                      py: 1.5,
                      borderRadius: 2,
                      fontWeight: 600,
                      textTransform: 'uppercase',
                      letterSpacing: 1,
                      '&:hover': {
                        bgcolor: '#00cec9',
                        transform: 'scale(1.02)'
                      },
                      transition: 'all 0.3s ease'
                    }}
                  >
                    {onlyTrainer ? 'Contratar Ahora' : 'Seleccionar Paquete'}
                  </Button>
                </CardActions>
              </Card>
            </Grid>
          );
        })}
      </Grid>
    </Box>
  );
};

export default PersonalTrainerPage;
import React, { useEffect, useState } from 'react';
import {
  Box,
  Grid,
  Card,
  CardContent,
  CardMedia,
  Typography,
  Button,
  CardActions,
  Backdrop,
  CircularProgress
} from '@mui/material';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import { useNavigate, useLocation } from 'react-router-dom';
import apiClient from '../../Apis/apiConfig';
import { Plan } from '../../Store/interface/Plan.ts';
import PesasCadaDia from '../../assets/Pesas-cada-dia.jpg';


const ServicePage = () => {
  const [plans, setPlans] = useState<Plan[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  
  // NUEVO: estado para mostrar el spinner al solicitar pago
  const [paymentLoading, setPaymentLoading] = useState<boolean>(false);

  const { isAuth, token } = useSelector((state: RootState) => state.auth);
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const fetchPlans = async () => {
      try {
        const response = await apiClient.get('/plans');
        setPlans(response.data);
      } catch (error) {
        console.error('Error fetching plans:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchPlans();
  }, []);

  const handleSubscribe = async (planId: number) => {
    if (!isAuth) {
      alert('Por favor, inicia sesión para continuar.');
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }

    // Activa el spinner
    setPaymentLoading(true);

    try {
      if (!token) {
        alert('Token no encontrado. Por favor, inicia sesión nuevamente.');
        navigate('/auth/login', { state: { from: location.pathname } });
        setPaymentLoading(false); // Apagar spinner
        return;
      }

      const config = {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      };

      const response = await apiClient.post(`/payment/create_plan_preference?planId=${planId}`, {}, config);
      
      const preference = response.data;
      window.location.href = preference.initPoint;  // Redirección MercadoPago
    } catch (error) {
      console.error('Error al crear la preferencia de pago:', error);
      alert('Ocurrió un error al procesar tu solicitud. Por favor, intenta nuevamente.');
      setPaymentLoading(false); // Apagar spinner si ocurre error
    }
  };

  const handlePlanPlusTrainer = (planId: number) => {
    if (!isAuth) {
      alert('Por favor, inicia sesión para continuar.');
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }

    // Aquí NO llamas al backend directamente, solo navegas.
    // Entonces NO necesitas spinner. O si quieres, lo puedes poner.
    navigate(`/personal-trainer?planId=${planId}`);
  };

  const handleOnlyTrainer = () => {
    if (!isAuth) {
      alert('Por favor, inicia sesión para continuar.');
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }
    navigate(`/personal-trainer?onlyTrainer=true`);
  };

  if (loading) {
    return <Typography>Cargando planes...</Typography>;
  }

  return (
    <Box sx={{ 
      padding: 6,
      minHeight: '100vh',
      backgroundColor: 'white',
      color: '#2a2a2a'
    }}>
      <Backdrop open={paymentLoading} sx={{ 
        zIndex: 9999,
        backgroundColor: 'rgba(255, 255, 255, 0.9)'
      }}>
        <CircularProgress size={80} color="primary" />
      </Backdrop>

      <Typography variant="h3" align="center" gutterBottom sx={{
        fontWeight: 'bold',
        mb: 8,
        textTransform: 'uppercase',
        color: '#1976d2',
        letterSpacing: 4,
        position: 'relative',
        '&::after': {
          content: '""',
          display: 'block',
          width: '60px',
          height: '4px',
          backgroundColor: '#1976d2',
          margin: '20px auto 0'
        }
      }}>
        Transforma tu Cuerpo
      </Typography>

      <Grid container spacing={6} justifyContent="center">
        {plans.map((plan) => (
          <Grid item xs={12} sm={6} md={4} key={plan.id}>
            <Card sx={{ 
              display: 'flex', 
              flexDirection: 'column',
              height: '100%',
              borderRadius: 4,
              transition: 'transform 0.3s, box-shadow 0.3s',
              '&:hover': {
                transform: 'translateY(-10px)',
                boxShadow: '0 10px 20px rgba(25, 118, 210, 0.2)'
              },
              backgroundColor: 'white',
              border: '1px solid #e0e0e0',
              position: 'relative'
            }}>
              <CardMedia
                component="img"
                height="220"
                image={PesasCadaDia}
                alt="Pesas cada día"
                sx={{
                  objectFit: 'cover',
                  position: 'relative'
                }}
              />

              <CardContent sx={{ 
                flexGrow: 1,
                position: 'relative',
                zIndex: 2
              }}>
                <Typography variant="h4" component="div" sx={{
                  fontWeight: 'bold',
                  mb: 2,
                  color: '#1976d2',
                  textTransform: 'uppercase'
                }}>
                  {plan.name}
                </Typography>
                
                <Typography variant="body1" sx={{ 
                  color: '#666666',
                  minHeight: 80,
                  mb: 3
                }}>
                  {plan.description || 'Descripción del plan'}
                </Typography>

                {plan.discount ? (
                  <Box sx={{ 
                    background: 'rgba(255, 50, 50, 0.1)',
                    p: 2,
                    borderRadius: 2,
                    position: 'relative',
                    overflow: 'hidden',
                    border: '1px solid #ff4444'
                  }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <Box>
                        <Typography variant="h6" sx={{ 
                          textDecoration: 'line-through',
                          color: '#ff4444'
                        }}>
                          ${plan.price}
                        </Typography>
                        <Typography variant="h4" sx={{
                          color: '#1976d2',
                          fontWeight: 'bold',
                          lineHeight: 1
                        }}>
                          ${plan.price - plan.price * (plan.discount / 100)}
                        </Typography>
                      </Box>
                      <Box sx={{
                        background: '#ff4444',
                        color: 'white',
                        px: 2,
                        py: 1,
                        borderRadius: 2,
                        textAlign: 'center'
                      }}>
                        <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                          -{plan.discount}%
                        </Typography>
                        <Typography variant="caption">
                          {plan.discountReason}
                        </Typography>
                      </Box>
                    </Box>
                  </Box>
                ) : (
                  <Typography variant="h4" sx={{ 
                    fontWeight: 'bold',
                    color: '#1976d2',
                    textAlign: 'center'
                  }}>
                    ${plan.price}
                  </Typography>
                )}
              </CardContent>

              <CardActions sx={{
                flexDirection: 'column',
                gap: 2,
                p: 3,
                position: 'relative',
                zIndex: 2
              }}>
                <Button
                  fullWidth
                  variant="contained"
                  onClick={() => handleSubscribe(plan.id)}
                  sx={{
                    background: 'linear-gradient(45deg, #1976d2 0%, #1565c0 100%)',
                    color: 'white',
                    fontWeight: 'bold',
                    py: 1.5,
                    '&:hover': {
                      transform: 'scale(1.02)',
                      boxShadow: '0 5px 15px rgba(25, 118, 210, 0.4)'
                    },
                    transition: 'transform 0.3s, box-shadow 0.3s'
                  }}
                >
                  Comprar Plan
                </Button>

                <Button
                  fullWidth
                  variant="outlined"
                  onClick={() => handlePlanPlusTrainer(plan.id)}
                  sx={{
                    borderColor: '#1976d2',
                    color: '#1976d2',
                    fontWeight: 'bold',
                    py: 1.5,
                    '&:hover': {
                      backgroundColor: 'rgba(25, 118, 210, 0.1)',
                      borderWidth: 2
                    }
                  }}
                >
                  + Personal Trainer
                </Button>

                <Typography variant="caption" sx={{
                  color: '#666666',
                  textAlign: 'center',
                  mt: 1
                }}>
                  *Tarifa variable según entrenador
                </Typography>
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>

      <Box sx={{ 
        marginTop: 8,
        textAlign: 'center',
        borderTop: '2px solid #e0e0e0',
        pt: 6
      }}>
        <Typography variant="h4" sx={{ 
          mb: 4,
          fontWeight: 'bold',
          color: '#1976d2'
        }}>
          ¿Solo necesitas un entrenador?
        </Typography>
        <Button
          variant="contained"
          onClick={handleOnlyTrainer}
          sx={{
            background: 'linear-gradient(45deg, #1976d2 0%, #1565c0 100%)',
            color: 'white',
            fontWeight: 'bold',
            px: 6,
            py: 2,
            fontSize: '1.1rem',
            '&:hover': {
              transform: 'scale(1.05)',
              boxShadow: '0 5px 20px rgba(25, 118, 210, 0.4)'
            },
            transition: 'transform 0.3s, box-shadow 0.3s'
          }}
        >
          Contratar Entrenador Personal
        </Button>
      </Box>
    </Box>
  );
};

export default ServicePage;

export * from './AppRouter';// src/router/AppRouter.tsx
import { Suspense, lazy } from 'react';
import { Navigate, Route, Routes } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../store';
import MainLayout from '../components/layout/MainLayout';
import LoadingSpinner from '../components/LoadingSpinner';
import GymInfoForm from '../Admin/pages/GymInfoForm';



// Páginas públicas - Lazy load
const HomePage = lazy(() => import('../pages/HomePage/HomePage'));
const AboutUsPage = lazy(() => import('../pages/AboutUsPage/AboutUsPage'));
const ServicesPage = lazy(() => import('../pages/ServicePage/ServicePage'));
const LoginPage = lazy(() => import('../Auth/pages').then(module => ({ default: module.LoginPage })));
const RegistrationPageRedirect = lazy(() => import('../Auth/pages/Register/RegistrationPageRedirect'));
const PaymentSuccessPage = lazy(() => import('../Users/pages/mercadoPago/PaymentSuccessPage'));
const PersonalTrainerPage = lazy(() => import('../pages/personalTrainer/PersonalTrainer'));
const StoreHomePage = lazy(() => import('../Store/pages/StoreHomePage'));
const ProteinaPage = lazy(() => import('../Store/pages/ProteinaPage'));
const CreatinaPage = lazy(() => import('../Store/pages/CreatinaPage'));
const ProductDetailPage = lazy(() => import('../Store/pages/ProductDetailPage'));
const CartPage = lazy(() => import('../Store/pages/CartPage'));

// Páginas protegidas - Lazy load
const UserDashboard = lazy(() => import('../Users/pages/UserDashboard').then(module => ({ default: module.UserDashboard })));
const DashboardAdmin = lazy(() => import('../Admin/pages/AdminDashBoardPage'));
const UsersPage = lazy(() => import('../Admin/pages/userPage').then(module => ({ default: module.UsersPage })));
const TrainerDashboard = lazy(() => import('../Trainers/pages/TrainerDashboard'));
const CarouselAdminPage = lazy(() => import('../Admin/pages/CarouselAdminPage'));
const TrainerProfileEditPage = lazy(() => import('../Trainers/pages/TrainerProfileEditPage').then(module => ({ default: module.TrainerProfileEditPage })));
const TrainerCalendarPage = lazy(() => import('../Trainers/pages/TrainerCalendarPage'));
const AssignTrainerAvailabilityPage = lazy(() => import('../Admin/pages/AdminTrainerAvailabilityForm'));
const AddMeasurementPage = lazy(() => import('../Trainers/pages/AddMeasurementPage'));
const AddRoutinePage = lazy(() => import('../Trainers/pages/AddRoutinePage'));
const MeasurementsPage = lazy(() => import('../Users/pages/MeasurementsPage'));
const GroupClassesCreatePage = lazy(() => import('../Admin/pages/GroupClassesCreatePage').then(module => ({ default: module.GroupClassesCreatePage })));
const GroupClassesAssignTrainerPage = lazy(() => import('../Admin/hooks/GroupClassesAssignTrainerPage').then(module => ({ default: module.GroupClassesAssignTrainerPage })));

const TrainerCalendar = lazy(() => import('../components/Trainer-Calendar/TrainerCalendar'));
const TrainerSessionsCalendar = lazy(() => import('../Users/components/TrainerSessionsCalendar'));
const CategoryCrud = lazy(() => import('../Admin/pages/CategoryCrud').then(module => ({ default: module.CategoryCrud })));
const ProductCrud = lazy(() => import('../Admin/pages/ProductCrud').then(module => ({ default: module.ProductCrud })));

const AdminPlanCrudPage = lazy(() => import('../Admin/pages/AdminPlanCrudPage'));
const PaymentFailurePage = lazy(() => import('../Users/pages/mercadoPago/PaymentPendingPage'));
const AdminFacturasPage = lazy(() => import('../Admin/pages/AdminFacturasPage'));
const AdminPlanesPage = lazy(() => import('../Admin/pages/AdminPlanesPage'));

export const AppRouter = () => {
  const { isAuth } = useSelector((state: RootState) => state.auth);

  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<MainLayout />}>
          {/* Rutas públicas */}
          <Route index element={<HomePage />} />
          <Route path="about" element={<AboutUsPage />} />
          <Route path="services" element={<ServicesPage />} />
          <Route path="auth/login" element={<LoginPage />} />
          <Route path="auth/register" element={<RegistrationPageRedirect />} />
          <Route path="success" element={<PaymentSuccessPage />} />
          <Route path="failure" element={<PaymentFailurePage />} />
          <Route path="personal-trainer" element={<PersonalTrainerPage />} />
          <Route path="store" element={<StoreHomePage />} />
          <Route path="store/page/:page" element={<StoreHomePage />} />
          <Route path="store/proteina" element={<ProteinaPage />} />
          <Route path="store/creatina" element={<CreatinaPage />} />
          <Route path="store/product/:id" element={<ProductDetailPage />} />
          <Route path="cart" element={<CartPage />} />

          {/* Rutas protegidas */}
          <Route path="dashboard" element={isAuth ? <UserDashboard /> : <Navigate to="/auth/login" />} />
          <Route path="admin/dashboard" element={isAuth ? <DashboardAdmin /> : <Navigate to="/auth/login" />} />
          <Route 
          path="admin/users/page/:page" 
          element={isAuth ? <UsersPage /> : <Navigate to="/auth/login" />} 
        />
            <Route
            path="admin/gym-info"
            element={isAuth ? <GymInfoForm /> : <Navigate to="/auth/login" />}
          />
        // Redirección desde ruta base
        <Route 
          path="admin/users" 
          element={<Navigate to="/admin/users/page/0" replace />} 
        />
          <Route path="admin/carousel" element={isAuth ? <CarouselAdminPage /> : <Navigate to="/auth/login" />} />
          <Route path="admin/group-classes/create" element={isAuth ? <GroupClassesCreatePage /> : <Navigate to="/auth/login" />} />
          <Route path="admin/group-classes/assign-trainer" element={isAuth ? <GroupClassesAssignTrainerPage /> : <Navigate to="/auth/login" />} />
          <Route path="admin/trainer-availability" element={isAuth ? <AssignTrainerAvailabilityPage /> : <Navigate to="/auth/login" />} />
          <Route path="admin/store/categories" element={isAuth ? <CategoryCrud /> : <Navigate to="/auth/login" />} />


          <Route path="admin/store/products/page/:page" element={isAuth ? <ProductCrud /> : <Navigate to="/auth/login" />} />

          <Route path="admin/store/products" element={isAuth ? <ProductCrud /> : <Navigate to="/auth/login" />} />

          <Route path="admin/plans" element={isAuth ? <AdminPlanCrudPage /> : <Navigate to="/auth/login" />} />
          <Route path="admin/facturas/page/:page" element={isAuth ? <AdminFacturasPage /> : <Navigate to="/auth/login" />} />
          <Route 
          path="admin/planes/page/:page" 
          element={isAuth ? <AdminPlanesPage /> : <Navigate to="/auth/login" />} />


        <Route 
          path="admin/planes" 
          element={<Navigate to="/admin/planes/page/0" replace />} 
        />

        <Route 
          path="trainers/dashboard" 
          element={isAuth ? <TrainerDashboard /> : <Navigate to="/auth/login" />} 
        />
                  <Route 
          path="trainers/edit-profile" 
          element={isAuth ? <TrainerProfileEditPage /> : <Navigate to="/auth/login" />} 
        />
                  <Route path="trainer/calendar" element={isAuth ? <TrainerCalendarPage /> : <Navigate to="/auth/login" />} />
                  <Route 
          path="trainers/clients/:clientId/measurements/add" // ✅ Ruta dinámica
          element={isAuth ? <AddMeasurementPage /> : <Navigate to="/auth/login" />} 
        />
                  <Route path="trainer/add-routine" element={isAuth ? <AddRoutinePage /> : <Navigate to="/auth/login" />} />

                  <Route 
          path="users/measurements" 
          element={isAuth ? <MeasurementsPage /> : <Navigate to="/auth/login" />} 
        />

                  <Route path="dashboard/trainer-sessions" element={isAuth ? <TrainerSessionsCalendar /> : <Navigate to="/auth/login" />} />

                  <Route 
          path="dashboard/calendar" 
          element={isAuth ? <TrainerSessionsCalendar /> : <Navigate to="/auth/login" />} 
        />

<Route
  path="trainers/my-calendar"
  element={isAuth ? <TrainerCalendar /> : <Navigate to="/auth/login" />}
/>



          <Route path="*" element={<Navigate to="/" />} />
        </Route>
      </Routes>
    </Suspense>
  );
};import apiClient from '../Apis/apiConfig';

export const getDiscountedProducts = async () => {
  try {
    // Ajusta la ruta según tu backend (aquí asumo '/store/products/offers')
    const response = await apiClient.get('/store/products/offers');
    return response.data;
  } catch (error) {
    console.error('Error al obtener productos en oferta:', error);
    throw error;
  }
};

// src/utils/discount.ts
import { Product } from '../Store/interface/Product';

export const getDiscountedPrice = (product: Product) => {
  const now = new Date();
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;
  
  let isDiscountActive = false;
  if (
    product.discountPercent && 
    product.discountPercent > 0 && 
    start && 
    end && 
    now >= start && 
    now <= end
  ) {
    isDiscountActive = true;
  }

  const originalPrice = product.price;
  let finalPrice = product.price;
  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return { originalPrice, finalPrice, isDiscountActive, discountReason: isDiscountActive ? product.discountReason : null };
};


import apiClient from '../Apis/apiConfig';


export const getCarouselImages = async () => {
  try {
    const response = await apiClient.get('/carousel/images');
    console.log("aqui esta la data",response);
    return response.data;
  } catch (error) {
    console.error('Error al obtener las imágenes del carrusel:', error);
    throw error;
  }
};







export { getCarouselImages } from './getCarouselImages';
export { uploadCarouselImage } from './uploadCarouselImage';import privateApi from "../Apis/apiConfig";

export const uploadCarouselImage = async (
  file: File,
  caption: string,
  orderNumber: number
) => {
  try {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('caption', caption);
    formData.append('orderNumber', orderNumber.toString());

    const response = await privateApi.post('/carousel/images', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });

    return response.data;
  } catch (error) {
    console.error('Error al subir imagen al carrusel:', error);
    throw error;
  }
};




// src/services/TrainerService.ts

import apiClient from '../../Apis/apiConfig';

export const getWeeklySlots = async (trainerId: number) => {
  try {
    const response = await apiClient.get(`/trainer-schedule/${trainerId}/weekly-slots`);
    console.log("aqui los horarios disponibles",response.data);
    return response.data;
  } catch (error) {
    console.error('Error al obtener los slots de tiempo:', error);
    throw error;
  }
};

/**
 * Reserva un slot de tiempo para un entrenador específico.
 * @param trainerId ID del entrenador.
 * @param slotStart ISO string de la hora de inicio del slot.
 * @returns Respuesta de la reserva.
 */
export const bookSlot = async (trainerId: number, slotStart: string) => {
    try {
      const response = await apiClient.post(
        '/trainer-schedule/book',
        null, // Enviar cuerpo vacío
        {
          params: { trainerId, slotStart }, // Enviar ambos como parámetros de consulta
        }
      );
      return response;
    } catch (error: any) {
      console.error('Error al reservar el slot:', error);
      throw error;
    }
  };
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { getCarouselImages } from '../services/getCarouselImages';

// Definimos el estado inicial del slice
interface CarouselState {
  images: Array<{
    id: number;
    imageUrl: string;
    caption: string;
    orderNumber: number;
  }>;
  loading: boolean;
  error: string | null;
}

// Estado inicial
const initialState: CarouselState = {
  images: [],
  loading: false,
  error: null,
};

// Creamos una thunk asincrónica que haga la petición al backend
export const fetchCarouselImages = createAsyncThunk(
  'carousel/fetchImages',
  async (_, { rejectWithValue }) => {
    try {
      const data = await getCarouselImages();  // Petición a tu backend
      return data;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

// Creamos el slice
export const carouselSlice = createSlice({
  name: 'carousel',
  initialState,
  reducers: {
    // Si deseas algún reducer extra, puedes ponerlo aquí.
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchCarouselImages.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCarouselImages.fulfilled, (state, action: PayloadAction<any[]>) => {
        state.loading = false;
        state.error = null;
        state.images = action.payload; // Guardamos las imágenes
      })
      .addCase(fetchCarouselImages.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string || 'Error al cargar imágenes';
      });
  },
});

export default carouselSlice.reducer;
import React from 'react';
import {
  Typography,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  FormControlLabel,
  Checkbox,
  Box,
  styled
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

interface FilterSectionProps {
  checkBoxInStock: boolean;
  setCheckBoxInStock: React.Dispatch<React.SetStateAction<boolean>>;
  
  selectedBrands: string[];
  setSelectedBrands: React.Dispatch<React.SetStateAction<string[]>>;
  
  selectedFlavors: string[];
  setSelectedFlavors: React.Dispatch<React.SetStateAction<string[]>>;

  brands: string[]; 
  flavors: string[];              // <-- Ahora recibimos flavors dinámicos
}

const StyledAccordion = styled(Accordion)({
  backgroundColor: '#1976d2',
  color: 'white',
  margin: '8px 0',
  borderRadius: '8px',
  '&:before': {
    display: 'none',
  },
  '&.Mui-expanded': {
    margin: '8px 0',
  },
});

const StyledAccordionSummary = styled(AccordionSummary)({
  '& .MuiAccordionSummary-expandIconWrapper': {
    color: 'white',
  },
  '&:hover': {
    backgroundColor: '#1565c0',
  },
});

const StyledCheckbox = styled(Checkbox)({
  color: 'white !important',
  '&.Mui-checked': {
    color: '#ff4081 !important',
  },
});

const FilterSection: React.FC<FilterSectionProps> = ({
  checkBoxInStock,
  setCheckBoxInStock,
  selectedBrands,
  setSelectedBrands,
  selectedFlavors,
  setSelectedFlavors,
  brands,
  flavors, 
}) => {

  const handleInStockChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCheckBoxInStock(e.target.checked);
  };

  const handleBrandToggle = (brand: string) => {
    setSelectedBrands((prev) =>
      prev.includes(brand) ? prev.filter((b) => b !== brand) : [...prev, brand]
    );
  };

  const handleFlavorToggle = (flavor: string) => {
    setSelectedFlavors((prev) =>
      prev.includes(flavor) ? prev.filter((f) => f !== flavor) : [...prev, flavor]
    );
  };

  return (
    <Box display="flex" flexDirection="column" gap={1} sx={{ p: 2 }}>
      <Typography variant="h6" gutterBottom sx={{ 
        color: '#1976d2',
        fontWeight: 'bold',
        textTransform: 'uppercase',
        letterSpacing: '1px'
      }}>
        Filtros
      </Typography>

      {/* Disponibilidad */}
      <StyledAccordion>
        <StyledAccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography sx={{ fontWeight: 500 }}>Disponibilidad</Typography>
        </StyledAccordionSummary>
        <AccordionDetails sx={{ bgcolor: '#f5f5f5' }}>
          <FormControlLabel
            control={
              <StyledCheckbox
                name="inStock"
                checked={checkBoxInStock}
                onChange={handleInStockChange}
              />
            }
            label="En existencia"
            sx={{ color: '#1976d2' }}
          />
        </AccordionDetails>
      </StyledAccordion>

      {/* Marcas */}
      <StyledAccordion>
        <StyledAccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography sx={{ fontWeight: 500 }}>Marca</Typography>
        </StyledAccordionSummary>
        <AccordionDetails sx={{ bgcolor: '#f5f5f5' }}>
          {brands.map((brand) => (
            <FormControlLabel
              key={brand}
              control={
                <StyledCheckbox
                  checked={selectedBrands.includes(brand)}
                  onChange={() => handleBrandToggle(brand)}
                />
              }
              label={brand}
              sx={{ color: '#1976d2', width: '100%', m: 0 }}
            />
          ))}
        </AccordionDetails>
      </StyledAccordion>

      {/* Sabores */}
      <StyledAccordion>
        <StyledAccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography sx={{ fontWeight: 500 }}>Sabor</Typography>
        </StyledAccordionSummary>
        <AccordionDetails sx={{ bgcolor: '#f5f5f5' }}>
          {flavors.length === 0 ? (
            <Typography variant="body2" sx={{ color: '#1976d2' }}>
              No hay sabores registrados.
            </Typography>
          ) : (
            flavors.map((flavor) => (
              <FormControlLabel
                key={flavor}
                control={
                  <StyledCheckbox
                    checked={selectedFlavors.includes(flavor)}
                    onChange={() => handleFlavorToggle(flavor)}
                  />
                }
                label={flavor}
                sx={{ color: '#1976d2', width: '100%', m: 0 }}
              />
            ))
          )}
        </AccordionDetails>
      </StyledAccordion>
    </Box>
  );
};

export default FilterSection;
// src/interfaces/Payment.ts

export interface PaymentPlanDTO {
    paymentId: number;
    planId: number;
    username: string;
    transactionAmount: number;
    status: string;
    paymentMethod: string | null;
    paymentDate: string;
    subscriptionStartDate: string;
    subscriptionEndDate: string;
    trainerSubscriptionStartDate: string;
    trainerSubscriptionEndDate: string;
    personalTrainerName: string | null;
  }
  
  export interface PaymentProductDTO {
    paymentId: number;
    username: string;
    paymentMethod: string | null;
    paymentDate: string;
    transactionAmount: number;
    productName: string;
  }
  export interface Plan {
    id?: number;
    name: string;
    price: number;
    description?: string;
    discount?: number;
    discountReason?: string; // <-- nuevo
    versionNumber?: number;
    active?: boolean;
  }
  
  export interface Product {
  id?: number;
  name: string;
  description?: string;
  imageUrl?: string;
  price: number;
  category: {
    id: number;
    name: string;
  };
  stock: number;
  flavor: string;
  brand: string;
  discountPercent: number;
  discountReason: string;
  discountStart?: string; // Agregar si es necesario
  discountEnd?: string;   // Agregar si es necesario
}




export interface Trainer {
  id: number;
  username: string;
  email: string;
  specialization: string;
  experienceYears: number;
  availability: boolean;
  profileImageUrl: string;
  title: string;
  studies: string;
  certifications: string;
  description: string;
  monthlyFee: number; 
  instagramUrl?: string | null;
  whatsappNumber?: string | null;
  certificationFileUrl?: string | null;
}import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate, useLocation } from 'react-router-dom';
import { RootState } from '../../store';
import {
  removeFromCart,
  increaseQuantity,
  decreaseQuantity,
  CartItem
} from '../Store/slices/cartSlice';
import { Box, Typography, IconButton, Button } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import DeleteIcon from '@mui/icons-material/Delete';
import { createProductPreference } from '../services/ProductService';
import Swal from 'sweetalert2';

/**
 * Función auxiliar para calcular el precio con descuento.
 */
function getDiscountedPrice(item: CartItem) {
  const { product } = item;
  const now = new Date();
  
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;

  let isDiscountActive = false;
  if (
    product.discountPercent &&
    product.discountPercent > 0 &&
    start && end &&
    now >= start &&
    now <= end
  ) {
    isDiscountActive = true;
  }

  const originalPrice = product.price;
  let finalPrice = product.price;
  
  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return {
    originalPrice,
    finalPrice,
    isDiscountActive,
    discountReason: isDiscountActive ? product.discountReason : null
  };
}

const CartPage: React.FC = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  
  const { items } = useSelector((state: RootState) => state.cart);
  const { isAuth } = useSelector((state: RootState) => state.auth);

  if (items.length === 0) {
    return (
      <Box sx={{ p: 2 }}>
        <Typography variant="h5">Tu carrito está vacío</Typography>
      </Box>
    );
  }

  // Calcular el total del carrito
  const totalPrice = items.reduce((acc, item) => {
    const { finalPrice } = getDiscountedPrice(item);
    return acc + finalPrice * item.quantity;
  }, 0);

  const handleCheckout = async () => {
    if (!isAuth) {
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }
    
    const payload = items.map(item => {
      const { finalPrice } = getDiscountedPrice(item);
      return {
        productId: item.product.id,
        unitPrice: finalPrice,
        quantity: item.quantity,
      };
    });

    try {
      const response = await createProductPreference(payload);
      const { initPoint } = response;
      if (initPoint) {
        window.location.href = initPoint;
      }
    } catch (error) {
      console.error('Error al procesar el checkout:', error);
      alert('Error durante el proceso de compra.');
    }
  };

  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h4" gutterBottom>
        Carrito de Compras
      </Typography>

      {items.map(item => {
        const { originalPrice, finalPrice, isDiscountActive, discountReason } = getDiscountedPrice(item);
        // Calculamos el stock disponible para este ítem
        const availableStock = item.product.stock - item.quantity;

        return (
          <Box
            key={item.product.id}
            display="flex"
            alignItems="center"
            justifyContent="space-between"
            sx={{ borderBottom: '1px solid #ccc', py: 1 }}
          >
            <Box display="flex" alignItems="center">
              <img
                src={item.product.imageUrl}
                alt={item.product.name}
                style={{
                  width: '80px',
                  height: '80px',
                  objectFit: 'cover',
                  marginRight: '16px',
                  borderRadius: '8px',
                }}
              />
              <Box>
                <Typography variant="h6">{item.product.name}</Typography>
                {/* Mostrar stock disponible */}
                <Typography variant="body2">
                  Stock disponible: {availableStock} {availableStock === 1 ? 'unidad' : 'unidades'}
                </Typography>
                
                {isDiscountActive ? (
                  <Box>
                    <Typography
                      variant="body2"
                      sx={{ textDecoration: 'line-through', color: 'gray' }}
                    >
                      ${originalPrice.toFixed(2)}
                    </Typography>
                    <Typography
                      variant="body1"
                      sx={{ color: 'red', fontWeight: 'bold' }}
                    >
                      ${finalPrice.toFixed(2)} (x {item.quantity})
                    </Typography>
                    {discountReason && (
                      <Typography
                        variant="body2"
                        sx={{ color: 'red', fontStyle: 'italic' }}
                      >
                        {discountReason}
                      </Typography>
                    )}
                  </Box>
                ) : (
                  <Typography variant="body2">
                    ${originalPrice.toFixed(2)} (x {item.quantity})
                  </Typography>
                )}
              </Box>
            </Box>

            <Box display="flex" alignItems="center">
              <IconButton
                color="primary"
                onClick={() => dispatch(decreaseQuantity(item.product.id))}
              >
                <RemoveIcon />
              </IconButton>
              <Typography sx={{ mx: 1 }}>{item.quantity}</Typography>
              <IconButton
                color="primary"
                // Deshabilitamos el botón si no hay stock disponible
                onClick={() => {
                  if (availableStock > 0) {
                    dispatch(increaseQuantity(item.product.id));
                  } else {
                    Swal.fire({
                      title: 'Sin stock',
                      text: 'No hay unidades disponibles para agregar.',
                      icon: 'error'
                    });
                  }
                }}
                disabled={availableStock <= 0}
              >
                <AddIcon />
              </IconButton>
              <IconButton
                color="error"
                onClick={() => dispatch(removeFromCart(item.product.id))}
              >
                <DeleteIcon />
              </IconButton>
            </Box>
          </Box>
        );
      })}

      <Box mt={2}>
        <Typography variant="h6">
          Total: ${totalPrice.toFixed(2)}
        </Typography>
        <Button
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
          onClick={handleCheckout}
        >
          Pagar Ahora
        </Button>
      </Box>
    </Box>
  );
};

export default CartPage;
import React from 'react';

const CreatinaPage: React.FC = () => {
    return (
        <div>
            <h1>Aquí está CreatinaPage</h1>
        </div>
    );
};

export default CreatinaPage;
import React, { useEffect, useState } from 'react';
import { useParams, useLocation, useNavigate, Link } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  IconButton,
  Grid,
  Divider,
  Chip,
  Stack,
  Skeleton,
  useTheme,
  useMediaQuery
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import LocalOfferIcon from '@mui/icons-material/LocalOffer';
import { getProductById, createProductPreference } from '../../Store/services/ProductService';
import { useDispatch, useSelector } from 'react-redux';
import { addToCart, increaseQuantity, decreaseQuantity, Product } from '../../Store/Store/slices/cartSlice';
import { RootState } from '../../store';
import Swal from 'sweetalert2';

function getDiscountedPrice(product: Product) {
  const now = new Date();
  
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;

  let isDiscountActive = false;
  if (
    product.discountPercent &&
    product.discountPercent > 0 &&
    start && end &&
    now >= start &&
    now <= end
  ) {
    isDiscountActive = true;
  }

  const originalPrice = product.price;
  let finalPrice = product.price;
  
  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return {
    originalPrice,
    finalPrice,
    isDiscountActive,
    discountReason: isDiscountActive ? product.discountReason : null
  };
}

const ProductDetailPage: React.FC = () => {
  const { id } = useParams();
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const [product, setProduct] = useState<Product | null>(null);
  const { items: cartItems } = useSelector((state: RootState) => state.cart);
  const { isAuth } = useSelector((state: RootState) => state.auth);

  // Se busca si ya existe este producto en el carrito
  const cartItem = cartItems.find(item => item.product.id === Number(id));
  const quantityInCart = cartItem ? cartItem.quantity : 0;
  
  // Estado local para la cantidad a agregar desde el detalle
  const [quantity, setQuantity] = useState(1); 

  useEffect(() => {
    const fetchProduct = async () => {
      const productId = parseInt(id || '', 10);
      if (isNaN(productId)) {
        console.error('ID del producto no válido:', id);
        return;
      }
      try {
        const productData = await getProductById(productId);
        setProduct(productData);
      } catch (error) {
        console.error('Error al obtener el producto:', error);
      }
    };
    fetchProduct();
  }, [id]);

  const handleIncrease = () => {
    setQuantity(prev => prev + 1);
  };
  
  const handleDecrease = () => {
    setQuantity(prev => Math.max(1, prev - 1)); // No permitir menos de 1
  };

  const handleAddToCart = () => {
    if (product) {
      // Calculamos el stock disponible: stock total del producto - cantidad ya en el carrito
      const availableStock = product.stock - quantityInCart;
      
      // Validamos que el stock disponible sea suficiente para la cantidad que se quiere agregar
      if (availableStock >= quantity) {
        dispatch(addToCart({ product, quantity })); // Agrega la cantidad seleccionada
        Swal.fire({
          title: '¡Agregado!',
          text: `Has agregado ${quantity} unidad${quantity > 1 ? 'es' : ''} de "${product.name}" al carrito.`,
          icon: 'success',
          timer: 1500,
          showConfirmButton: false,
        });
      } else {
        Swal.fire({
          title: 'Sin stock',
          text: 'Lo sentimos, no hay suficientes unidades disponibles para agregar.',
          icon: 'error',
        });
      }
    }
  };

  const handleBuyNow = async () => {
    if (!product) return;

    if (!isAuth) {
      await Swal.fire({
        title: 'Acceso requerido',
        text: 'Debes iniciar sesión para realizar una compra. Serás redirigido al login.',
        icon: 'warning',
        confirmButtonText: 'Aceptar'
      });
      navigate('/auth/login', { state: { from: location.pathname } });
      return;
    }

    const { finalPrice } = getDiscountedPrice(product);
    const payload = [{
      productId: product.id,
      unitPrice: finalPrice,
      quantity: quantity, // Usar cantidad local
    }];

    try {
      const response = await createProductPreference(payload);
      if (response.initPoint) {
        window.location.href = response.initPoint;
      }
    } catch (error) {
      console.error('Error al procesar el pago:', error);
      alert('Error al procesar el pago.');
    }
  };

  if (!product) {
    return (
      <Box sx={{ p: 3 }}>
        <Skeleton variant="rectangular" width="100%" height={400} />
        <Box sx={{ mt: 2 }}>
          <Skeleton width="60%" height={40} />
          <Skeleton width="40%" height={30} />
          <Skeleton width="30%" height={30} />
        </Box>
      </Box>
    );
  }

  // Obtenemos datos del descuento
  const { originalPrice, finalPrice, isDiscountActive, discountReason } = getDiscountedPrice(product);
  // Calculamos el stock disponible en detalle (stock total - cantidad en carrito)
  const availableStock = product.stock - quantityInCart;

  return (
    <Box sx={{ p: 3, maxWidth: 1200, margin: '0 auto' }}>
      <Grid container spacing={4}>
        <Grid item xs={12} md={6}>
          <Box sx={{
            position: 'relative',
            borderRadius: 2,
            overflow: 'hidden',
            bgcolor: 'background.paper',
            boxShadow: 2,
            padding: 2
          }}>
            {product.imageUrl && (
              <img
                src={product.imageUrl}
                alt={product.name}
                style={{
                  width: '100%',
                  height: 'auto',
                  objectFit: 'contain',
                  maxHeight: '500px'
                }}
              />
            )}
            {isDiscountActive && (
              <Chip
                label="¡Oferta!"
                color="error"
                icon={<LocalOfferIcon />}
                sx={{
                  position: 'absolute',
                  top: 16,
                  right: 16,
                  fontSize: '1rem',
                  padding: 1
                }}
              />
            )}
          </Box>
        </Grid>

        <Grid item xs={12} md={6}>
          <Typography 
            variant="h3" 
            component="h1" 
            gutterBottom
            sx={{ 
              fontWeight: 700,
              color: theme.palette.text.primary
            }}
          >
            {product.name}
          </Typography>

          <Typography 
            variant="body1" 
            paragraph
            sx={{
              fontSize: '1.1rem',
              lineHeight: 1.6,
              color: theme.palette.text.secondary,
              mb: 4
            }}
          >
            {product.description || 'Sin descripción disponible.'}
          </Typography>

          {/* Mostrar precio y, a continuación, stock restante */}
          <Box sx={{ mb: 4 }}>
            {isDiscountActive ? (
              <Stack direction="row" alignItems="center" spacing={2}>
                <Typography
                  variant="h4"
                  sx={{
                    color: theme.palette.error.main,
                    fontWeight: 700
                  }}
                >
                  ${finalPrice.toFixed(2)} c/u
                </Typography>
                <Typography
                  variant="h6"
                  sx={{
                    textDecoration: 'line-through',
                    color: theme.palette.text.disabled
                  }}
                >
                  ${originalPrice.toFixed(2)}
                </Typography>
              </Stack>
            ) : (
              <Typography
                variant="h4"
                sx={{
                  fontWeight: 700,
                  color: theme.palette.text.primary
                }}
              >
                ${originalPrice.toFixed(2)} c/u
              </Typography>
            )}
            
            {/* Mostrar stock disponible en detalle */}
            <Typography variant="body2" sx={{ mt: 1 }}>
              Stock disponible: {availableStock} {availableStock === 1 ? 'unidad' : 'unidades'}
            </Typography>

            {/* Mostrar el total basado en la cantidad en el carrito (si fuera necesario) */}
            <Typography variant="h6" sx={{ mt: 2 }}>
              Total: ${(finalPrice * quantityInCart).toFixed(2)}
            </Typography>

            {discountReason && (
              <Chip
                label={discountReason}
                color="info"
                size="small"
                sx={{ mt: 1, fontSize: '0.9rem' }}
              />
            )}
          </Box>

          <Divider sx={{ my: 3 }} />

          <Box sx={{ mb: 4 }}>
            <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
              Cantidad:
            </Typography>
            <Stack direction="row" alignItems="center" spacing={2}>
              <IconButton 
                onClick={handleDecrease} 
                color="primary"
                sx={{
                  border: `1px solid ${theme.palette.primary.main}`,
                  borderRadius: '8px'
                }}
              >
                <RemoveIcon />
              </IconButton>
              <Typography 
                variant="h6" 
                sx={{ 
                  minWidth: '40px', 
                  textAlign: 'center',
                  fontWeight: 600
                }}
              >
                {quantity} 
              </Typography>
              <IconButton 
                onClick={handleIncrease} 
                color="primary"
                sx={{
                  border: `1px solid ${theme.palette.primary.main}`,
                  borderRadius: '8px'
                }}
              >
                <AddIcon />
              </IconButton>
            </Stack>
          </Box>

          <Stack 
            direction={isMobile ? "column" : "row"} 
            spacing={2} 
            sx={{ mt: 4 }}
          >
          <Button
            variant="contained"
            color="primary"
            onClick={handleBuyNow}
            disabled={availableStock <= 0} // Se deshabilita si no hay stock
            size="large"
            fullWidth
            sx={{
              py: 1.5,
              fontSize: '1.1rem',
              textTransform: 'none'
            }}
          >
            Comprar ahora ({quantity} unidades)
          </Button>

            
            <Button
              variant="outlined"
              color="secondary"
              onClick={handleAddToCart}
              size="large"
              fullWidth
              sx={{
                py: 1.5,
                fontSize: '1.1rem',
                textTransform: 'none'
              }}
            >
              Añadir al carrito
            </Button>
          </Stack>
        </Grid>
      </Grid>
    </Box>
  );
};

export default ProductDetailPage;
import React from 'react';

const ProteinaPage: React.FC = () => {
    return (
        <div>
            <h1>Aquí está ProteinaPage</h1>
        </div>
    );
};

export default ProteinaPage;
import React from 'react';
import { useLocation, useParams, Link, useNavigate } from 'react-router-dom';
import {
  Box,
  Grid,
  TextField,
  Typography,
  FormControl,
  Select,
  MenuItem,
  InputLabel,
  Button
} from '@mui/material';
import Swal from 'sweetalert2';
import { useDispatch } from 'react-redux';

import { useSearch } from '../../Admin/hooks/useSearch';
import { Product } from '../../Store/interface/Product';
import { Paginator } from '../../Admin/components/Paginator';
import FilterSection from '../components/FilterSection';
import { useProducts } from '../../Hooks/useProducts';
import { addToCart } from '../../Store/Store/slices/cartSlice';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';


/**
 * Calcula el precio final con descuento si está en rango de fechas.
 * Retorna un objeto con:
 *   - originalPrice (number)
 *   - finalPrice (number)
 *   - isDiscountActive (boolean)
 *   - discountReason (string | null)
 */
function getDiscountedPrice(product: Product) {
  const now = new Date();

  // Parsear discountStart y discountEnd si existen
  const start = product.discountStart ? new Date(product.discountStart) : null;
  const end = product.discountEnd ? new Date(product.discountEnd) : null;

  // Chequear si 'hoy' está dentro del rango [start, end] y si discountPercent > 0
  let isDiscountActive = false;
  if (
    product.discountPercent &&
    product.discountPercent > 0 &&
    start && end &&
    now >= start &&
    now <= end
  ) {
    isDiscountActive = true;
  }

  // Calcular precios
  const originalPrice = product.price;
  let finalPrice = product.price;

  if (isDiscountActive) {
    finalPrice = finalPrice - (finalPrice * product.discountPercent / 100);
  }

  return {
    originalPrice,
    finalPrice,
    isDiscountActive,
    discountReason: isDiscountActive ? product.discountReason : null
  };
}


const StoreHomePage: React.FC = () => {
  const { searchTerm, setSearchTerm } = useSearch();
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const category = queryParams.get('category');
  const { page } = useParams();
  const pageNumber = page ? parseInt(page, 10) : 0;

  // Hook para despachar acciones
  const dispatch = useDispatch();
  const navigate = useNavigate(); // si quieres redirigir en algún momento

  const cartItems = useSelector((state: RootState) => state.cart.items);

  const isSearching = searchTerm.trim() !== '';

  // Hook personalizado
  const {
    products,
    paginator,
    loading,
    sortBy,
    setSortBy,
    checkBoxInStock,
    setCheckBoxInStock,
    selectedBrands,
    setSelectedBrands,
    selectedFlavors,
    setSelectedFlavors,
    priceRange,
    setPriceRange,
    brands,
    flavors,
  } = useProducts({
    searchTerm,
    category,
    pageNumber,
  });

  // Manejar ordenamiento
  const handleSortChange = (event: React.ChangeEvent<{ value: unknown }>) => {
    const newSort = event.target.value as string;
    setSortBy(newSort);
  };

  // Filtrado adicional en front (si lo deseas)
  const finalProducts = products.filter((p) => {
    return p.price >= priceRange[0] && p.price <= priceRange[1];
  });

  // Al hacer clic en “Agregar al carrito”
  const handleAddToCart = (product: Product, availableStock: number) => {
    if (availableStock > 0) {
      dispatch(addToCart({ product, quantity: 1 }));
      Swal.fire({
        title: '¡Agregado!',
        text: `Has agregado "${product.name}" al carrito.`,
        icon: 'success',
        timer: 1500,
        showConfirmButton: false,
      });
    } else {
      Swal.fire({
        title: 'Sin stock',
        text: 'Lo sentimos, este producto se encuentra agotado.',
        icon: 'error',
      });
    }
  };
  

  return (
    <Box display="flex" padding={2}>
      {/* Columna lateral de filtros */}
      <Box width="20%" paddingRight={2}>
        <FilterSection
          checkBoxInStock={checkBoxInStock}
          setCheckBoxInStock={setCheckBoxInStock}
          selectedBrands={selectedBrands}
          setSelectedBrands={setSelectedBrands}
          selectedFlavors={selectedFlavors}
          setSelectedFlavors={setSelectedFlavors}
          priceRange={priceRange}
          setPriceRange={setPriceRange}
          brands={brands}
          flavors={flavors}
        />
      </Box>

      <Box flex={1}>
        {/* Encabezado y Orden */}
        <Box
          display="flex"
          justifyContent="space-between"
          alignItems="center"
          position="relative"
        >
          <Typography variant="h4" gutterBottom>
            {category ? `Productos de ${category}` : 'Todos los Productos'}
          </Typography>

          {/* Dropdown de ordenamiento */}
          <Box sx={{ position: 'absolute', right: '120px', top: '50px' }}>
            <FormControl sx={{ minWidth: 200 }} size="small">
              <InputLabel id="sort-select-label">Ordenar</InputLabel>
              <Select
                labelId="sort-select-label"
                value={sortBy}
                onChange={handleSortChange}
              >
                <MenuItem value="price_asc">Precio: Menor a Mayor</MenuItem>
                <MenuItem value="price_desc">Precio: Mayor a Menor</MenuItem>
                <MenuItem value="best_selling">Más Vendidos</MenuItem>
              </Select>
            </FormControl>
          </Box>
        </Box>

        {/* Barra de búsqueda */}
        <Box mb={4}>
          <TextField
            variant="outlined"
            size="small"
            placeholder="Buscar productos..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            label="Buscar"
            sx={{ maxWidth: '300px' }}
          />
        </Box>

        {loading ? (
          <Typography variant="body1">Cargando productos...</Typography>
        ) : !finalProducts || finalProducts.length === 0 ? (
          <Typography variant="body1">No se encontraron productos.</Typography>
        ) : (
          <Grid container spacing={2}>
 {finalProducts.map((product) => {
  // Calculamos los datos de descuento
  const {
    originalPrice,
    finalPrice,
    isDiscountActive,
    discountReason,
  } = getDiscountedPrice(product);

  // Obtenemos la cantidad que ya se agregó al carrito para este producto
  const cartItem = cartItems.find(item => item.product.id === product.id);
  const quantityInCart = cartItem ? cartItem.quantity : 0;
  // Calculamos el stock disponible (stock original menos la cantidad en el carrito)
  const availableStock = product.stock - quantityInCart;

  return (
    <Grid item xs={12} sm={6} md={3} key={product.id}>
      <Box
        sx={{
          border: '1px solid #ccc',
          borderRadius: '4px',
          padding: 2,
          textAlign: 'center',
          position: 'relative',
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'space-between',
        }}
      >
        {isDiscountActive && (
          <Box
            sx={{
              position: 'absolute',
              top: 0,
              left: 0,
              backgroundColor: 'red',
              color: 'white',
              padding: '4px 8px',
              borderRadius: '0 0 4px 0',
            }}
          >
            ¡Oferta!
          </Box>
        )}

        {product.imageUrl && (
          <Box
            sx={{
              width: '100%',
              height: '180px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              overflow: 'hidden',
              marginBottom: '8px',
            }}
          >
            <img
              src={product.imageUrl}
              alt={product.name}
              style={{
                width: 'auto',
                height: '100%',
                objectFit: 'cover',
              }}
            />
          </Box>
        )}

        <Typography
          variant="h6"
          component={Link}
          to={`/store/product/${product.id}`}
          sx={{
            textDecoration: 'none',
            color: 'inherit',
            '&:hover': {
              textDecoration: 'underline',
            },
          }}
        >
          {product.name}
        </Typography>

        {/* Mostrar stock disponible basado en lo agregado al carrito */}
        <Typography variant="body2" sx={{ mt: 1 }}>
          Stock disponible: {availableStock} unidades
        </Typography>

        {isDiscountActive ? (
          <Box sx={{ mt: 1, mb: 2 }}>
            <Typography
              variant="body2"
              sx={{ textDecoration: 'line-through', color: 'gray' }}
            >
              ${originalPrice.toFixed(2)}
            </Typography>
            <Typography
              variant="h6"
              sx={{ color: 'red', fontWeight: 'bold' }}
            >
              ${finalPrice.toFixed(2)}
            </Typography>
            {discountReason && (
              <Typography
                variant="body2"
                sx={{ color: 'red', fontStyle: 'italic' }}
              >
                {discountReason}
              </Typography>
            )}
          </Box>
        ) : (
          <Typography variant="h6" sx={{ my: 2 }}>
            ${originalPrice.toFixed(2)}
          </Typography>
        )}

        {/* Botón Agregar al Carrito */}
        <Button
          variant="contained"
          color="primary"
          onClick={() => handleAddToCart(product, availableStock)}
        >
          Agregar al Carrito
        </Button>
      </Box>
    </Grid>
  );
})}

          </Grid>
        )}

        {/* Paginador (solo si NO estamos buscando) */}
        {!isSearching && paginator.totalPages > 1 && (
          <Paginator
            url="/store"
            paginator={{
              number: paginator.number,
              totalPages: paginator.totalPages,
              first: paginator.first,
              last: paginator.last,
            }}
            sortBy={sortBy}
          />
        )}
      </Box>
    </Box>
  );
};

export default StoreHomePage;
// src/services/CategoryService.ts
import apiClient from '../../Apis/apiConfig'; // asumiendo que apiClient ya está configurado

export interface Category {
  id: number;
  name: string;
}

export const getAllCategories = async (): Promise<Category[]> => {

  const response = await apiClient.get('/store/categories');

  return response.data;
};
    // src/Store/services/ProductService.ts
    import apiClient from '../../Apis/apiConfig';
import { Product } from '../interface/Product';
import { CartItem } from '../Store/slices/cartSlice';
import { Category } from './CategoryService';


interface ProductPage {
  content: Product[];
  number: number;      // página actual
  totalPages: number;  // total de páginas
  first: boolean;
  last: boolean;
 
}
  interface AdvancedSearchPayload {
    page: number;
    size: number;
    sortBy: string;
  
    // Filtros
    category?: string|null;
    inStock?: boolean;
    brands?: string[];
    flavors?: string[];
    minPrice?: number;
    maxPrice?: number;
    // ...
  }

  
  export const getAllProducts = async (): Promise<Product[]> => {
      console.log("AQUI LLEGA");
    const response = await apiClient.get('/store/products');
    console.log("AQUI LA RESPONSE",response);
    return response.data;
  };

 
  export const getProductsByCategory = async (categoryName: string): Promise<Product[]> => {
    const response = await apiClient.get('/store/products', {
      params: {
        category: categoryName,
      },
    });
    return response.data;
  };


  export const getProductById = async (id: number) => {
    console.log("AQUI ESTA EL ID DEL PRODUCTO",id);
    const response = await apiClient.get(`/store/products/${id}`);
    console.log("AQUI LA RESPONSE",response);
    return response.data;
  };

  export const getProductsPage = async (
    page: number,
    size: number,
    category?: string,
    sortBy?: string
  ): Promise<ProductPage> => {
    // Parametrizamos la llamada
    const params: any = {};
    if (category) params.category = category;
    if (sortBy) params.sortBy = sortBy;
    params.size = size;
  
    const response = await apiClient.get(`/store/products/page/${page}`, { params });
    console.log("obtener datos paginacion getProductPage",response);
    return response.data;  
  };
  

  // ProductService.ts (frontend)
export const getProductsBySearch = async (term: string): Promise<Product[]> => {
  const response = await apiClient.get('/store/products/search', {
    params: { term },
  });
  console.log("response",response);
  return response.data; // un array de Product
};

export const createProductPreference = async (items: CartItem[]) => {
 
    // Enviar solicitud POST con los items del carrito
    const response = await apiClient.post('/payment/create_product_preference', items);

    console.log('Preferencia de pago creada:', response.data);
    return response.data;  // Retorna el punto de inicio del checkout (initPoint)
    

};

export const getDistinctBrands = async (): Promise<string[]> => {
  const response = await apiClient.get('/store/products/brands');
  return response.data;
};

export const getDistinctFlavors = async (): Promise<string[]> => {
  const response = await apiClient.get('/store/products/flavors');
  return response.data;
};


export async function advancedSearchProducts(
  payload: AdvancedSearchPayload
): Promise<ProductPage> {
  const {
    page,
    size,
    sortBy,
    category,
    inStock,
    brands,
    flavors,
    minPrice,
    maxPrice,
  } = payload;

  const params: any = {
    page,
    size,
    sortBy,
    minPrice,
    maxPrice,
  };
  if (category) params.category = category;
  if (inStock !== undefined) params.inStock = inStock;
  if (brands && brands.length > 0) params.brands = brands.join(',');
  if (flavors && flavors.length > 0) params.flavors = flavors.join(',');

  const response = await apiClient.get('/store/products/search2', { params });
  console.log("search2 response", response);
  return response.data;
}

export const getAllCategories = async (): Promise<Category[]> => {
  const response = await apiClient.get('/store/categories');
  return response.data;
};

export const createProduct = async (formData: FormData): Promise<Product> => {
  const response = await apiClient.post('/store/products', formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
  return response.data;
};
export const updateProduct = async (id: number, formData: FormData): Promise<Product> => {
  console.log("aqui formData",formData);
  const response = await apiClient.put(`/store/products/${id}`, formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
  return response.data;
};



export const deleteProduct = async (id: number): Promise<void> => {
  await apiClient.delete(`/store/products/${id}`);
};








// src/Store/slices/cartSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Product } from '../../interface/Product';

// Estructura para guardar producto + cantidad
export interface CartItem {
  product: Product;
  quantity: number;
}

// Estado inicial del slice
interface CartState {
  items: CartItem[];
}

// Estado inicial
const initialState: CartState = {
  items: [],
};

export const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    // Agregar un producto al carrito con una cantidad dada
    addToCart: (state, action: PayloadAction<{ product: Product; quantity: number }>) => {
      const { product, quantity } = action.payload;

      // Ver si el producto ya está en el carrito
      const existingItem = state.items.find((item) => item.product.id === product.id);

      if (existingItem) {
        // Si existe, incrementamos la cantidad
        existingItem.quantity += quantity;
      } else {
        // Si no existe, lo agregamos
        state.items.push({ product, quantity });
      }
    },

    // Quitar un producto del carrito
    removeFromCart: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      state.items = state.items.filter((item) => item.product.id !== productId);
    },

    // Incrementar la cantidad de un producto en 1
    increaseQuantity: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      const item = state.items.find((item) => item.product.id === productId);
      if (item) {
        item.quantity += 1;
      }
    },

    // Decrementar la cantidad de un producto en 1 (sin bajar de 1)
    decreaseQuantity: (state, action: PayloadAction<number>) => {
      const productId = action.payload;
      const item = state.items.find((item) => item.product.id === productId);
      if (item && item.quantity > 1) {
        item.quantity -= 1;
      }
    },
  },
});

// Exportar actions y reducer
export const {
  addToCart,
  removeFromCart,
  increaseQuantity,
  decreaseQuantity,
} = cartSlice.actions;

export default cartSlice.reducer;

import { Select, MenuItem, CircularProgress, Typography } from '@mui/material';
import { useClients } from '../hooks/useClients';




const ClientSelect: React.FC<{ onSelect: (clientId: number) => void }> = ({ onSelect }) => {
    const { clients, loading, error } = useClients();
  
    if (loading) {
      return <CircularProgress />;
    }
  
    if (error) {
      return <Typography color="error">{error}</Typography>;
    }
  
    return (
      <Select fullWidth defaultValue="" onChange={(e) => onSelect(Number(e.target.value))}>
        <MenuItem value="" disabled>
          Selecciona un cliente
        </MenuItem>
        {clients.map((client) => (
          <MenuItem key={client.id} value={client.id}>
            {client.username} ({client.email})
          </MenuItem>
        ))}
      </Select>
    );
  };
  
  export default ClientSelect;
import React, { useState } from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import {
  Box,
  Button,
  TextField,
  Typography,
  Alert,
  Checkbox,
  FormControlLabel,
  Divider,
} from '@mui/material';
import { DateTimePicker, LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format } from 'date-fns';
import { addBodyMeasurement } from '../../services/trainerClientService';
import Swal from 'sweetalert2';

interface FormValues {
  date: Date;
  clientName: string;
  age: string;
  injuries: string;
  otherHealthInfo: string;
  medications: string;
  currentlyExercising: boolean;
  sportsPracticed: string;
  weight: string;
  bmi: string;
  relaxedArm: string;
  waist: string;
  midThigh: string;
  flexedArm: string;
  hips: string;
  calf: string;
  tricepFold: string;
  subscapularFold: string;
  bicepFold: string;
  suprailiacFold: string;
  sumOfFolds: string;
  percentageOfFolds: string;
  fatMass: string;
  leanMass: string;
  muscleMass: string;
  idealMinWeight: string;
  idealMaxWeight: string;
  trainerRecommendations: string;
  height: string;
  bodyFatPercentage: string;
}

interface AddMeasurementFormProps {
  clientId: number;
}

const AddMeasurementForm: React.FC<AddMeasurementFormProps> = ({ clientId }) => {
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitSuccess, setSubmitSuccess] = useState<boolean>(false);

  const validationSchema = Yup.object({
    date: Yup.date().required('Fecha de evaluación es requerida'),
    clientName: Yup.string(),
    age: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    injuries: Yup.string(),
    otherHealthInfo: Yup.string(),
    medications: Yup.string(),
    currentlyExercising: Yup.boolean(),
    sportsPracticed: Yup.string(),
    weight: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo')
      .required('Peso es requerido'),
    bmi: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    relaxedArm: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    waist: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    midThigh: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    flexedArm: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    hips: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    calf: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    tricepFold: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    subscapularFold: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    bicepFold: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    suprailiacFold: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    sumOfFolds: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    percentageOfFolds: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    fatMass: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    leanMass: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    muscleMass: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    idealMinWeight: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    idealMaxWeight: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo'),
    trainerRecommendations: Yup.string(),
    height: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo')
      .required('Altura es requerida'),
    bodyFatPercentage: Yup.number()
      .typeError('Debe ser un número')
      .positive('Debe ser positivo')
      .required('Porcentaje de grasa es requerido'),
  });

  const formik = useFormik<FormValues>({
    initialValues: {
      date: new Date(),
      clientName: '',
      age: '',
      injuries: '',
      otherHealthInfo: '',
      medications: '',
      currentlyExercising: false,
      sportsPracticed: '',
      weight: '',
      bmi: '',
      relaxedArm: '',
      waist: '',
      midThigh: '',
      flexedArm: '',
      hips: '',
      calf: '',
      tricepFold: '',
      subscapularFold: '',
      bicepFold: '',
      suprailiacFold: '',
      sumOfFolds: '',
      percentageOfFolds: '',
      fatMass: '',
      leanMass: '',
      muscleMass: '',
      idealMinWeight: '',
      idealMaxWeight: '',
      trainerRecommendations: '',
      height: '',
      bodyFatPercentage: '',
    },
    validationSchema,
    onSubmit: async (values) => {
      setSubmitError(null);
      try {
        const dateStr = format(values.date, "yyyy-MM-dd'T'HH:mm:ss");
        const measurementData = {
          ...values,
          date: dateStr,
          age: values.age ? Number(values.age) : 0, // Como 'age' no es requerido, asignamos 0 en caso de no tener valor
          weight: Number(values.weight),
          bmi: values.bmi ? Number(values.bmi) : 0,
          height: Number(values.height),
          bodyFatPercentage: Number(values.bodyFatPercentage),
          relaxedArm: values.relaxedArm ? Number(values.relaxedArm) : 0,
          waist: values.waist ? Number(values.waist) : 0,
          midThigh: values.midThigh ? Number(values.midThigh) : 0,
          flexedArm: values.flexedArm ? Number(values.flexedArm) : 0,
          hips: values.hips ? Number(values.hips) : 0,
          calf: values.calf ? Number(values.calf) : 0,
          tricepFold: values.tricepFold ? Number(values.tricepFold) : 0,
          subscapularFold: values.subscapularFold ? Number(values.subscapularFold) : 0,
          bicepFold: values.bicepFold ? Number(values.bicepFold) : 0,
          suprailiacFold: values.suprailiacFold ? Number(values.suprailiacFold) : 0,
          sumOfFolds: values.sumOfFolds ? Number(values.sumOfFolds) : 0,
          percentageOfFolds: values.percentageOfFolds ? Number(values.percentageOfFolds) : 0,
          fatMass: values.fatMass ? Number(values.fatMass) : 0,
          leanMass: values.leanMass ? Number(values.leanMass) : 0,
          muscleMass: values.muscleMass ? Number(values.muscleMass) : 0,
          idealMinWeight: values.idealMinWeight ? Number(values.idealMinWeight) : 0,
          idealMaxWeight: values.idealMaxWeight ? Number(values.idealMaxWeight) : 0,
        };

        await addBodyMeasurement(clientId, measurementData);
        formik.resetForm();

        Swal.fire({
          icon: 'success',
          title: '¡Medición guardada!',
          text: 'Los datos se han registrado correctamente',
          confirmButtonColor: '#3085d6',
          confirmButtonText: 'Aceptar',
        });
      } catch (error: any) {
        console.error('Error al agregar medición:', error);
        setSubmitError(error.response?.data || 'Error al agregar la medición');
      }
    },
  });

  return (
    <Box sx={{ maxWidth: 600, margin: '0 auto', mt: 4 }}>
      <Typography variant="h5" gutterBottom>
        Agregar Medición Corporal
      </Typography>
      <form onSubmit={formik.handleSubmit}>
        {/* Fecha de Evaluación */}
        <Typography variant="h6">Fecha de Evaluación</Typography>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DateTimePicker
            label="Fecha y Hora"
            value={formik.values.date}
            onChange={(value: Date | null) => formik.setFieldValue('date', value)}
            renderInput={(params) => <TextField {...params} fullWidth margin="normal" />}
          />
        </LocalizationProvider>

        {/* Información del Socio */}
        <Typography variant="h6">Información del Socio</Typography>
        <Divider />
        <TextField
          fullWidth
          label="Nombre del Socio"
          margin="normal"
          {...formik.getFieldProps('clientName')}
        />
        <TextField
          fullWidth
          label="Edad"
          margin="normal"
          type="number"
          {...formik.getFieldProps('age')}
        />

        {/* Información de Salud */}
        <Typography variant="h6">Información de Salud</Typography>
        <Divider />
        <TextField fullWidth label="Lesiones" margin="normal" {...formik.getFieldProps('injuries')} />
        <TextField fullWidth label="Otros" margin="normal" {...formik.getFieldProps('otherHealthInfo')} />
        <TextField fullWidth label="Medicamentos" margin="normal" {...formik.getFieldProps('medications')} />

        {/* Información Deportiva */}
        <Typography variant="h6">Información Deportiva</Typography>
        <Divider />
        <FormControlLabel
          control={<Checkbox {...formik.getFieldProps('currentlyExercising')} />}
          label="Ejercita Actualmente"
        />
        <TextField fullWidth label="Deporte Practicado" margin="normal" {...formik.getFieldProps('sportsPracticed')} />

        {/* Información IMC */}
        <Typography variant="h6">Información IMC</Typography>
        <Divider />
        <TextField fullWidth label="Peso Actual (kg)" margin="normal" {...formik.getFieldProps('weight')} />
        <TextField fullWidth label="IMC" margin="normal" {...formik.getFieldProps('bmi')} />
        <TextField
          fullWidth
          label="Altura (cm)"
          margin="normal"
          type="number"
          {...formik.getFieldProps('height')}
          error={formik.touched.height && Boolean(formik.errors.height)}
          helperText={formik.touched.height && formik.errors.height}
        />
        <TextField
          fullWidth
          label="Porcentaje de Grasa Corporal (%)"
          margin="normal"
          type="number"
          {...formik.getFieldProps('bodyFatPercentage')}
          error={formik.touched.bodyFatPercentage && Boolean(formik.errors.bodyFatPercentage)}
          helperText={formik.touched.bodyFatPercentage && formik.errors.bodyFatPercentage}
        />

        {/* Información Perímetros Corporales */}
        <Typography variant="h6">Información Perímetros Corporales</Typography>
        <Divider />
        <TextField fullWidth label="Brazo Relajado" margin="normal" {...formik.getFieldProps('relaxedArm')} />
        <TextField fullWidth label="Cintura (mínimo)" margin="normal" {...formik.getFieldProps('waist')} />
        <TextField fullWidth label="Muslo Medio" margin="normal" {...formik.getFieldProps('midThigh')} />
        <TextField fullWidth label="Brazo Contraído" margin="normal" {...formik.getFieldProps('flexedArm')} />
        <TextField fullWidth label="Cadera (máximo)" margin="normal" {...formik.getFieldProps('hips')} />
        <TextField fullWidth label="Pantorrilla" margin="normal" {...formik.getFieldProps('calf')} />

        {/* Información Perfil Antropométrico */}
        <Typography variant="h6">Información Perfil Antropométrico</Typography>
        <Divider />
        <TextField fullWidth label="Tricipital" margin="normal" {...formik.getFieldProps('tricepFold')} />
        <TextField fullWidth label="Subescapular" margin="normal" {...formik.getFieldProps('subscapularFold')} />
        <TextField fullWidth label="Bicipital" margin="normal" {...formik.getFieldProps('bicepFold')} />
        <TextField fullWidth label="Supracrestideo" margin="normal" {...formik.getFieldProps('suprailiacFold')} />

        {/* Información de Interpretación */}
        <Typography variant="h6">Información de Interpretación de Datos</Typography>
        <Divider />
        <TextField fullWidth label="Suma de Pliegues" margin="normal" {...formik.getFieldProps('sumOfFolds')} />
        <TextField fullWidth label="% de Pliegues" margin="normal" {...formik.getFieldProps('percentageOfFolds')} />
        <TextField fullWidth label="Masa Adiposa (kg)" margin="normal" {...formik.getFieldProps('fatMass')} />
        <TextField fullWidth label="Masa Libre de Grasa (kg)" margin="normal" {...formik.getFieldProps('leanMass')} />
        <TextField fullWidth label="Masa Muscular (kg)" margin="normal" {...formik.getFieldProps('muscleMass')} />

        {/* Peso Ideal */}
        <Typography variant="h6">Peso Ideal</Typography>
        <Divider />
        <TextField fullWidth label="Peso Ideal Mínimo" margin="normal" {...formik.getFieldProps('idealMinWeight')} />
        <TextField fullWidth label="Peso Ideal Máximo" margin="normal" {...formik.getFieldProps('idealMaxWeight')} />
        <TextField fullWidth label="Recomendaciones para el Entrenador" margin="normal" {...formik.getFieldProps('trainerRecommendations')} />

        {submitError && <Alert severity="error" sx={{ mt: 2 }}>{submitError}</Alert>}
        {submitSuccess && <Alert severity="success" sx={{ mt: 2 }}>Medición añadida con éxito</Alert>}

        <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
          <Button variant="contained" color="primary" type="submit">
            Guardar
          </Button>
        </Box>
      </form>
    </Box>
  );
};

export default AddMeasurementForm;
// src/Trainers/components/forms/AddRoutineForm.tsx
import React, { useState } from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import {
  Box, Button, TextField, Typography, Alert
} from '@mui/material';
import { DateTimePicker, LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format } from 'date-fns';
import { addRoutine } from '../../services/trainerClientService';

interface AddRoutineFormProps {
  clientId: number;
}

const AddRoutineForm: React.FC<AddRoutineFormProps> = ({ clientId }) => {
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitSuccess, setSubmitSuccess] = useState<boolean>(false);

  const validationSchema = Yup.object({
    title: Yup.string().required('El título es requerido'),
    description: Yup.string().required('La descripción es requerida'),
    assignedDate: Yup.date().required('La fecha de asignación es requerida')
  });

  const formik = useFormik({
    initialValues: {
      title: '',
      description: '',
      assignedDate: new Date(),
    },
    validationSchema,
    onSubmit: async (values) => {
      setSubmitError(null);
      setSubmitSuccess(false);
      try {
        const dateStr = values.assignedDate ? format(values.assignedDate, "yyyy-MM-dd'T'HH:mm:ss") : '';
        await addRoutine(clientId, {
          title: values.title,
          description: values.description,
          assignedDate: dateStr,
        });
        setSubmitSuccess(true);
        formik.resetForm();
      } catch (error: any) {
        console.error('Error al agregar rutina:', error);
        setSubmitError(error.response?.data || 'Error al agregar la rutina');
      }
    },
  });

  return (
    <Box sx={{ maxWidth: 400, margin: '0 auto', mt: 4 }}>
      <Typography variant="h5" gutterBottom>Agregar Rutina</Typography>
      <form onSubmit={formik.handleSubmit}>
        <TextField
          fullWidth
          margin="normal"
          label="Título de la rutina"
          name="title"
          value={formik.values.title}
          onChange={formik.handleChange}
          error={formik.touched.title && Boolean(formik.errors.title)}
          helperText={formik.touched.title && formik.errors.title}
        />
        <TextField
          fullWidth
          margin="normal"
          label="Descripción"
          name="description"
          value={formik.values.description}
          onChange={formik.handleChange}
          error={formik.touched.description && Boolean(formik.errors.description)}
          helperText={formik.touched.description && formik.errors.description}
          multiline
          rows={4}
        />

        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DateTimePicker
            label="Fecha y Hora de asignación"
            value={formik.values.assignedDate}
            onChange={(value: Date | null) => formik.setFieldValue('assignedDate', value)}
            renderInput={(params: any) => (
              <TextField
                {...params}
                fullWidth
                margin="normal"
                error={formik.touched.assignedDate && Boolean(formik.errors.assignedDate)}
                helperText={formik.touched.assignedDate && formik.errors.assignedDate}
              />
            )}
          />
        </LocalizationProvider>

        {submitError && <Alert severity="error" sx={{ mt: 2 }}>{submitError}</Alert>}
        {submitSuccess && <Alert severity="success" sx={{ mt: 2 }}>Rutina añadida con éxito</Alert>}

        <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
          <Button variant="contained" color="primary" type="submit">
            Guardar
          </Button>
        </Box>
      </form>
    </Box>
  );
};

export default AddRoutineForm;
import { useState, useEffect } from 'react';
import { getClients } from '../services/TrainerService';

interface Client {
  id: number;
  username: string;
  email: string;
  admin: boolean;
  trainer: boolean;
  profileImageUrl: string | null;
}

export const useClients = () => {
  const [clients, setClients] = useState<Client[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchClients = async () => {
      try {
        setLoading(true);
        const data = await getClients();
        setClients(data);
      } catch (err) {
        setError('Error al cargar los clientes');
      } finally {
        setLoading(false);
      }
    };

    fetchClients();
  }, []);

  return { clients, loading, error };
};
import React, { useState } from 'react';
import ClientSelect from '../components/ClientSelect';
import AddMeasurementForm from '../components/forms/AddMeasurementForm';

const AddMeasurementFormWithClient: React.FC = () => {
  const [selectedClientId, setSelectedClientId] = useState<number | null>(null);

  const handleClientSelect = (clientId: number) => {
    setSelectedClientId(clientId);
  };

  return (
    <div>
      <h2>Seleccionar Cliente</h2>
      {/* Selector de cliente */}
      <ClientSelect onSelect={handleClientSelect} />

      {/* Mostrar el formulario si hay un cliente seleccionado */}
      {selectedClientId && (
        <div>
          <h3>Cliente Seleccionado: {selectedClientId}</h3>
          <AddMeasurementForm clientId={selectedClientId} />
        </div>
      )}
    </div>
  );
};

export default AddMeasurementFormWithClient;
import React, { useState } from 'react';
import ClientSelect from '../components/ClientSelect';
import AddRoutineForm from '../components/forms/AddRoutineForm';

const AddRoutineFormWithClient: React.FC = () => {
  const [selectedClientId, setSelectedClientId] = useState<number | null>(null);

  const handleClientSelect = (clientId: number) => {
    setSelectedClientId(clientId);
  };

  return (
    <div>
      <h2>Seleccionar Cliente</h2>
      {/* Selector de cliente */}
      <ClientSelect onSelect={handleClientSelect} />

      {/* Mostrar el formulario si hay un cliente seleccionado */}
      {selectedClientId && (
        <div>
          <h3>Cliente Seleccionado: {selectedClientId}</h3>
          <AddRoutineForm clientId={selectedClientId} />
        </div>
      )}
    </div>
  );
};

export default AddRoutineFormWithClient;
import React, { useEffect, useState } from 'react';
import { Calendar, dateFnsLocalizer } from 'react-big-calendar';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import { format, parse, startOfWeek, getDay } from 'date-fns';
import { enUS, es } from 'date-fns/locale';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import { getTrainerCalendarEvents, TrainerCalendarEvent } from '../services/TrainerService';
import { Box, Typography, CircularProgress, Alert } from '@mui/material';

// Config locales
const locales = {
  'en-US': enUS,
  es,
};

const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek: () => startOfWeek(new Date(), { weekStartsOn: 1 }),
  getDay,
  locales,
});

// Interfaz para usar en React Big Calendar (son las props mínimas del Event)
interface CalendarEvent {
  id: number;
  title: string;
  start: Date;
  end: Date;
  eventType: string; // "PERSONAL" | "GROUP"
}

// La página
const TrainerCalendarPage: React.FC = () => {
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError]   = useState<string | null>(null);

  // Roles y token del usuario
  const { user, token, roles } = useSelector((state: RootState) => state.auth);
  // Si en tu back integras un endpoint para /trainer-schedule/{trainerId}, 
  // aquí podrías sacar la info de trainerId.
  // Podrías obtener trainerId desde user?.id o de otra parte si tu back asume que user.id = trainerId
  // o tuviste que hacer un "GET /trainers" para ver si hay un personalTrainer asociado.

  // Supongamos que si es trainer, su "id" es también "trainerId" en PersonalTrainer. 
  // (puede que difieran, pero para el ejemplo haremos lo más sencillo)
  const trainerId = user?.id;  // Accede directamente desde el usuario autenticado
 
    console.log("AQUI ESTA EL ID DEL ENTRENADOR",trainerId);
  useEffect(() => {
    console.log("aqui calendario usuario");
    const fetchEvents = async () => {
        console.log("AQUI ESTA EL ID DEL ENTRENADOR",trainerId);
      if (!trainerId) {
        setError('No se encontró el ID del entrenador');
        setLoading(false);
        return;
      }
      try {
        const data = await getTrainerCalendarEvents(trainerId);
        console.log("aqui la data",data)
        const mappedEvents: CalendarEvent[] = data.map((evt) => ({
          id: evt.id,
          title: evt.title,
          start: new Date(evt.start),
          end:   new Date(evt.end),
          eventType: evt.eventType,
        }));
        setEvents(mappedEvents);
      } catch (err) {
        setError('Error al cargar el calendario del entrenador');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchEvents();
  }, [trainerId]);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" mt={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box display="flex" justifyContent="center" mt={4}>
        <Alert severity="error">{error}</Alert>
      </Box>
    );
  }

  return (
    <Box p={3}>
      <Typography variant="h4" gutterBottom>
        Mi Calendario (Entrenador)
      </Typography>
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: 600 }}
        defaultView="week"
        views={['week', 'day', 'agenda', 'month']}
        eventPropGetter={(event: CalendarEvent) => {
          // cambiar color si es personal o grupal
          let backgroundColor = event.eventType === 'PERSONAL' ? '#1976d2' : '#d81b60'; // por ejemplo
          return {
            style: {
              backgroundColor,
              color: '#fff',
            },
          };
        }}
      />
    </Box>
  );
};

export default TrainerCalendarPage;
// src/Trainers/pages/TrainerDashboard.tsx
import React, { useEffect, useState } from 'react';
import { getActiveClientsInfo, ActiveClientInfo } from '../../Trainers/services/TrainerService';
// Importar componentes de Material UI
import { 
  Box, 
  Grid, 
  Card, 
  CardContent, 
  Typography, 
  CardActions, 
  Divider 
} from '@mui/material';

const TrainerDashboard: React.FC = () => {
  const [clients, setClients] = useState<ActiveClientInfo[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchActiveClients = async () => {
      try {
        const data = await getActiveClientsInfo();
        setClients(data);
      } catch (err) {
        console.error('[TrainerDashboard] Error fetching clients info:', err);
        setError('Ocurrió un error al cargar la información de clientes.');
      } finally {
        setLoading(false);
      }
    };

    fetchActiveClients();
  }, []);

  if (loading) {
    return (
      <Box sx={{ p: 3 }}>
        <Typography variant="h6">Cargando información de clientes...</Typography>
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Typography variant="h6" color="error">{error}</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Bienvenido a tu Dashboard (Entrenador)
      </Typography>

      {clients.length === 0 ? (
        <Typography variant="body1">No hay clientes activos en este momento.</Typography>
      ) : (
        <Grid container spacing={2}>
          {clients.map((client) => (
            <Grid item xs={12} sm={6} md={4} key={client.clientId}>
              <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    {client.clientName}
                  </Typography>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    {client.clientEmail}
                  </Typography>

                  <Divider sx={{ my: 1 }} />

                  {/* Plan */}
                  <Typography variant="subtitle2" sx={{ mt: 1 }}>
                    <strong>Plan:</strong> {client.planName || '—'}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Inicio: {client.planStart ?? '—'} <br />
                    Fin: {client.planEnd ?? '—'}
                  </Typography>

                  <Divider sx={{ my: 1 }} />

                  {/* Entrenador */}
                  <Typography variant="subtitle2">
                    <strong>Entrenador:</strong> 
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Inicio: {client.trainerStart ?? '—'} <br />
                    Fin: {client.trainerEnd ?? '—'}
                  </Typography>
                </CardContent>

                <CardActions sx={{ mt: 'auto', p: 2 }}>
                  {/* Botones de acción que desees (por ejemplo, ver perfil del cliente o registrar medición). */}
                </CardActions>
              </Card>
            </Grid>
          ))}
        </Grid>
      )}
    </Box>
  );
};

export default TrainerDashboard;
import React, { useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  Typography,
  Avatar,
  Paper,
  Divider,
} from '@mui/material';
import { useAuth } from '../../Auth/hooks/useAuth';
import { updateTrainerProfile } from '../services/TrainerService';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import Swal from 'sweetalert2';
import { useDispatch } from 'react-redux';
import { updateProfile } from '../../Auth/store/auth/authSlice';
import { useNavigate } from 'react-router-dom';


export const TrainerProfileEditPage: React.FC = () => {
  const { login } = useAuth();
  const dispatch = useDispatch();
  const navigate = useNavigate();

  useEffect(() => {
    console.log('Login User:', login.user);
  }, [login.user]);

  const validationSchema = Yup.object({
    username: Yup.string().required('El nombre de usuario es requerido'),
    email: Yup.string()
      .email('Correo electrónico no válido')
      .required('El correo es requerido'),
    password: Yup.string()
      .min(6, 'La contraseña debe tener al menos 6 caracteres'),
    file: Yup.mixed().notRequired(),
    instagramUrl: Yup.string().notRequired(),
    whatsappNumber: Yup.string().notRequired(),
  });

  // Usa la información de login.user. Asegúrate de que si tienes información del entrenador esté en login.user.trainerInfo (o similar)
  const initialValues = {
    username: login.user?.username || '',
    email: login.user?.email || '',
    password: '',
    file: null as File | null,
    instagramUrl: login.user?.trainerDetails?.instagramUrl || '',
    whatsappNumber: login.user?.trainerDetails?.whatsappNumber || '',
  };
  
  

  const handleSubmit = async (
    values: typeof initialValues,
    { setSubmitting }: { setSubmitting: (isSubmitting: boolean) => void }
  ) => {
    const formData = new FormData();
    formData.append('username', values.username);
    formData.append('email', values.email);
    
    if (values.password) {
      formData.append('password', values.password);
    }
    
    if (values.file) {
      formData.append('file', values.file);
    }
    
    // Agregamos los nuevos campos
    formData.append('instagramUrl', values.instagramUrl || '');
    formData.append('whatsappNumber', values.whatsappNumber || '');
    
    try {
      const updatedUser = await updateTrainerProfile(formData);
      console.log("Usuario/trainer actualizado:", updatedUser);
    
      dispatch(updateProfile(updatedUser));
      Swal.fire({
        icon: 'success',
        title: 'Perfil actualizado',
        text: 'Tu perfil ha sido actualizado exitosamente.',
      });
    } catch (error: any) {
      console.error('Error actualizando perfil:', error);
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: error.response?.data || 'Ocurrió un error al actualizar el perfil.',
      });
    } finally {
      setSubmitting(false);
    }
  };
  

  return (
    <Box
      sx={{
        p: 3,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '80vh',
        background: '#f5f5f5',
      }}
    >
      <Paper elevation={3} sx={{ p: 4, width: '100%', maxWidth: 600 }}>
        <Typography variant="h4" align="center" gutterBottom>
          Editar Perfil
        </Typography>
        <Divider sx={{ my: 2 }} />
        <Formik
          initialValues={initialValues}
          validationSchema={validationSchema}
          onSubmit={handleSubmit}
          enableReinitialize
        >
          {({ handleChange, setFieldValue, values, isSubmitting, errors, touched }) => {
            useEffect(() => {
              if (values.file) {
                const objectUrl = URL.createObjectURL(values.file);
                return () => URL.revokeObjectURL(objectUrl);
              }
            }, [values.file]);

            return (
              <Form>
                <Box sx={{ mb: 2 }}>
                  <Field
                    as={TextField}
                    name="username"
                    label="Nombre de usuario"
                    fullWidth
                    variant="outlined"
                    helperText={<ErrorMessage name="username" />}
                    error={touched.username && Boolean(errors.username)}
                  />
                </Box>
                <Box sx={{ mb: 2 }}>
                  <Field
                    as={TextField}
                    name="email"
                    type="email"
                    label="Correo electrónico"
                    fullWidth
                    variant="outlined"
                    helperText={<ErrorMessage name="email" />}
                    error={touched.email && Boolean(errors.email)}
                  />
                </Box>
                <Box sx={{ mb: 2 }}>
                  <Field
                    as={TextField}
                    name="password"
                    type="password"
                    label="Nueva contraseña"
                    fullWidth
                    variant="outlined"
                    helperText={<ErrorMessage name="password" />}
                    error={touched.password && Boolean(errors.password)}
                  />
                </Box>
                <Box sx={{ mb: 2, display: 'flex', gap: 2 }}>
                  <TextField
                    fullWidth
                    variant="outlined"
                    label="Instagram"
                    name="instagramUrl"
                    value={values.instagramUrl}
                    onChange={handleChange}
                  />
                  <TextField
                    fullWidth
                    variant="outlined"
                    label="WhatsApp"
                    name="whatsappNumber"
                    value={values.whatsappNumber}
                    onChange={handleChange}
                  />
                </Box>
                <Box sx={{ mb: 2, display: 'flex', alignItems: 'center' }}>
                  <Avatar
                    alt={login.user?.username}
                    src={
                      values.file
                        ? URL.createObjectURL(values.file)
                        : login.user?.profileImageUrl || ''
                    }
                    sx={{ width: 60, height: 60, mr: 2 }}
                  />
                  <Button variant="contained" component="label">
                    Subir Imagen
                    <input
                      type="file"
                      hidden
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                        if (e.target.files && e.target.files[0]) {
                          setFieldValue('file', e.target.files[0]);
                        }
                      }}
                      accept="image/*"
                    />
                  </Button>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                  <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    size="large"
                    disabled={isSubmitting}
                  >
                    {isSubmitting ? 'Guardando...' : 'Guardar Cambios'}
                  </Button>
                </Box>
              </Form>
            );
          }}
        </Formik>
      </Paper>
    </Box>
  );
};
export default TrainerProfileEditPage; // src/Trainers/services/trainerClientService.ts
import apiClient from '../../Apis/apiConfig';

export interface BodyMeasurement {
  weight: number;
  height: number;
  bodyFatPercentage: number;
  date: string; // Formato ISO: "YYYY-MM-DDTHH:mm:ss"
}

export interface RoutineRequest {
  title: string;
  description: string;
  assignedDate: string; // también en formato ISO
}

export const addBodyMeasurement = async (clientId: number, measurement: BodyMeasurement) => {
  const response = await apiClient.post(`/trainers/clients/${clientId}/measurements`, measurement);
  return response.data;
};

export const addRoutine = async (clientId: number, routine: RoutineRequest) => {
  const response = await apiClient.post(`/trainers/clients/${clientId}/routines`, routine);
  return response.data;
};
// src/Trainers/services/TrainerService.ts

import { UserInterface } from '../../Auth/Interfaces/UserInterface';
import apiClient from '../../Apis/apiConfig';
import axios from 'axios';

// src/Trainers/services/TrainerService.ts

export const updateTrainerProfile = async (formData: FormData): Promise<UserInterface> => {
  console.log("AQUI ESTA LA DATA (Formulario):", {
    username: formData.get('username'),
    email: formData.get('email'),
    password: formData.get('password'),
    file: formData.get('file'),
  });
  
  const token = sessionStorage.getItem('token');
  
  if (!token) {
    throw new Error('Token de autenticación no encontrado');
  }

  const response = await apiClient.put<UserInterface>('/profile/update', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      Authorization: `Bearer ${token}`,
    },
  });

  console.log("Respuesta del servidor:", response.data);
  return response.data; // Retorna solo los datos del usuario
};



export const getClients = async () => {
  try {
    const response = await apiClient.get('/trainers/clients');
    console.log("AQUI LOS USUARIOS",response);
    return response.data;
  } catch (error) {
    console.error('[TrainerClientService] Error fetching clients:', error);
    throw error;
  }
};

export interface ActiveClientInfo {
  clientId: number;
  clientName: string;
  clientEmail: string;
  planName?: string;
  planStart?: string;  
  planEnd?: string;      
  trainerStart?: string;  
  trainerEnd?: string;    
}

export const getActiveClientsInfo = async (): Promise<ActiveClientInfo[]> => {
  const response = await apiClient.get('/trainers/active-clients-info');
  return response.data;
};

export interface TrainerCalendarEvent {
  id: number;
  title: string;
  start: string;  // ISO date string
  end:   string;  // ISO date string
  eventType: 'PERSONAL' | 'GROUP';  // o el string que tu backend devuelva
}

/**
 * Obtiene TODOS los eventos (personales + grupales) del entrenador con ID `trainerId`.
 */
export const getTrainerCalendarEvents = async (trainerId: number): Promise<TrainerCalendarEvent[]> => {
  const response = await apiClient.get(`/trainer-schedule/${trainerId}/calendar`);
  console.log("ACA LA RESPONSE",response);
  return response.data;
};

// src/types/sweetalert2-react-content.d.ts

declare module 'sweetalert2-react-content' {
    import Swal, { SweetAlertOptions, SweetAlertResult } from 'sweetalert2';
  
    interface ReactSwal extends typeof Swal {
      fire(options: SweetAlertOptions): Promise<SweetAlertResult<any>>;
    }
  
    function withReactContent(Swal: typeof Swal): ReactSwal;
  
    export default withReactContent;
  }
  import React, { useState, useEffect } from 'react';
import { Calendar, dateFnsLocalizer } from 'react-big-calendar';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import format from 'date-fns/format';
import parse from 'date-fns/parse';
import startOfWeek from 'date-fns/startOfWeek';
import getDay from 'date-fns/getDay';
import es from 'date-fns/locale/es';
import apiClient from '../../Apis/apiConfig';
import { CalendarEventDTO } from '../../Users/interfaces/GroupClass';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';

const locales = {
  'es': es,
};

const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek,
  getDay,
  locales,
});

const TrainerSessionsCalendar: React.FC = () => {
  const [events, setEvents] = useState<CalendarEventDTO[]>([]);

  // Obtener el ID del usuario autenticado desde Redux
  const userId = useSelector((state: RootState) => state.auth.user?.id);

  useEffect(() => {
    const fetchSessions = async () => {
      console.log("aqui el id del usuario",userId);
      if (!userId) return;

      try {
        const response = await apiClient.get(`/clients/${userId}/sessions`);
        console.log("aqui las sesiones",response);
        const sessions = response.data.map((event: CalendarEventDTO) => ({
          title: event.title,
          start: new Date(event.start),
          end: new Date(event.end),
        }));
        setEvents(sessions);
      } catch (error) {
        console.error('Error al cargar las sesiones:', error);
      }
    };

    fetchSessions();
  }, [userId]);

  return (
    <div style={{ height: 700 }}>
      <h2 style={{ textAlign: 'center' }}>Calendario de Sesiones</h2>
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ margin: '50px' }}
        views={['week']}             // Solo mostramos la vista de semana
        defaultView="week"           // Vista por defecto 'week'
      />
    </div>
  );
};

export default TrainerSessionsCalendar;
// src/hooks/useAvailableClasses.ts
import { useEffect, useState } from 'react';
import Swal from 'sweetalert2';  // Importar SweetAlert
import { getAvailableGroupClasses, GroupClass, bookGroupClass } from '../../Users/services/groupClassService';

export const useAvailableClasses = () => {
  const [classes, setClasses] = useState<GroupClass[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchClasses = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getAvailableGroupClasses();
      setClasses(data);
    } catch (err: any) {
      setError('Error al obtener las clases disponibles');
    } finally {
      setLoading(false);
    }
  };

  const bookClassById = async (classId: number) => {
    try {
      setLoading(true);
      setError(null);
      await bookGroupClass(classId);
      
      // Mostrar SweetAlert en caso de éxito
      Swal.fire({
        title: 'Reserva exitosa',
        text: 'Has reservado con éxito. Por favor, llega 5 minutos antes de la clase.',
        icon: 'success',
        confirmButtonText: 'Entendido'
      });

      // Refrescar la lista automáticamente después de reservar
      await fetchClasses();  
      
    } catch (err: any) {
      // Si el error es porque ya tiene una reserva
      if (err.response && err.response.data === "Ya tienes una reserva en esta clase") {
        Swal.fire({
          title: 'Reserva duplicada',
          text: 'Ya tienes una reserva para esta clase.',
          icon: 'info',
          confirmButtonText: 'OK'
        });
      } else {
        // Mensaje genérico para otros errores
        Swal.fire({
          title: 'Error al reservar',
          text: 'Hubo un problema al intentar reservar la clase. Verifica tu plan activo o el rango de reserva.',
          icon: 'error',
          confirmButtonText: 'Entendido'
        });
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchClasses();
  }, []);

  return { classes, loading, error, bookClassById };
};


export interface GroupClass {
    id: number;
    className: string;
    startTime: string; // ISO string
    endTime: string;   // ISO string
    maxParticipants: number;
    assignedTrainer?: {
      id: number;
      user: {
        username: string;
        email: string;
      };
      specialization?: string;
    };
  }

  export interface CalendarEventDTO {
    id: number;
    title: string;
    start: string;
    end: string;
    eventType: string;
  }
  import {  UserInterface } from "../../Auth/Interfaces/UserInterface";

export interface BodyMeasurement {
    id: number;
    client: UserInterface;
    trainer: UserInterface; // Cambiado a UserInterface
    clientName: string | null;
    weight: number | null;
    height: number | null;
    bodyFatPercentage: number | null;
    date: string; // ISO string
    injuries: string;
    medications: string;
    otherHealthInfo: string;
    currentlyExercising: boolean | null;
    sportsPracticed: string;
    currentWeight: number | null;
    bmi: number | null;
    relaxedArm: number | null;
    waist: number | null;
    midThigh: number | null;
    flexedArm: number | null;
    hips: number | null;
    calf: number | null;
    tricepFold: number | null;
    subscapularFold: number | null;
    bicepFold: number | null;
    suprailiacFold: number | null;
    sumOfFolds: number | null;
    percentageOfFolds: number | null;
    fatMass: number | null;
    leanMass: number | null;
    muscleMass: number | null;
    idealMinWeight: number | null;
    idealMaxWeight: number | null;
    trainerRecommendations: string;
    age: number | null;
    
}
// src/Users/pages/AvailableClassesPage.tsx

import React from 'react';
import { useAvailableClasses } from '../../Users/hooks/useAvailableClasses';
import { CircularProgress, Typography, Container, Box, Button, List, ListItem, ListItemText } from '@mui/material';
import { format } from 'date-fns';

export const AvailableClassesPage: React.FC = () => {
  const { classes, loading, error, bookClassById } = useAvailableClasses();

  const handleBook = (classId: number) => {
    bookClassById(classId);
  };

  if (loading) return (
    <Container>
      <Box display="flex" justifyContent="center" mt={4}>
        <CircularProgress />
      </Box>
    </Container>
  );

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Clases Grupales Disponibles
      </Typography>
      {error && <Typography color="error">{error}</Typography>}
      {classes.length === 0 && <Typography>No hay clases disponibles en este momento.</Typography>}

      <List>
  {classes.map((gc) => (
    <ListItem key={gc.id} sx={{ display: 'block', borderBottom: '1px solid #ccc', mb: 2 }}>
      <ListItemText
        primary={gc.className}
        secondary={
          <>
            <Typography>Inicio: {format(new Date(gc.startTime), 'dd/MM/yyyy HH:mm')}</Typography>
            <Typography>Fin: {format(new Date(gc.endTime), 'dd/MM/yyyy HH:mm')}</Typography>
            <Typography>Cupo Máx: {gc.maxParticipants}</Typography>
            <Typography>
              Cupos Disponibles: 
              <span style={{ color: gc.availableSlots === 0 ? 'red' : 'inherit' }}>
                {gc.availableSlots}
              </span>
            </Typography>
            {gc.assignedTrainer && (
              <Typography>Entrenador: {gc.assignedTrainer.user.username} ({gc.assignedTrainer.user.email})</Typography>
            )}
          </>
        }
      />
      <Button
        variant="contained"
        color={gc.availableSlots > 0 ? 'primary' : 'secondary'}
        onClick={() => handleBook(gc.id)}
        disabled={gc.availableSlots === 0}
      >
        {gc.availableSlots > 0 ? 'Reservar' : 'Sin cupo'}
      </Button>
    </ListItem>
  ))}
</List>

    </Container>
  );
};
// src/Users/pages/MeasurementsPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Typography,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  CircularProgress,
  Alert,
  Box,
  Grid,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import measurementService from '../../Users/services/measurementService';
import { BodyMeasurement } from '../../Users/models/BodyMeasurement';
import { useAuth } from '../../Auth/hooks/useAuth';

const MeasurementsPage: React.FC = () => {
    const { login } = useAuth();
    console.log("Contenido de login:", login);
const user = login?.user || null
console.log("Usuario obtenido:", user);

  const [measurements, setMeasurements] = useState<BodyMeasurement[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (user && user.id) {
      measurementService
        .getMeasurements(user.id)
        .then((response) => {
            console.log(response.data);
          setMeasurements(response.data);
          setLoading(false);
        })
        .catch((err) => {
          setError('Error al obtener las mediciones.');
          setLoading(false);
        });
    } else {
      setError('Usuario no autenticado.');
      setLoading(false);
    }
  }, [user]);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" mt={5}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box display="flex" justifyContent="center" mt={5}>
        <Alert severity="error">{error}</Alert>
      </Box>
    );
  }

  if (measurements.length === 0) {
    return (
      <Box display="flex" justifyContent="center" mt={5}>
        <Alert severity="info">No hay mediciones disponibles.</Alert>
      </Box>
    );
  }

  return (
    <Box p={3}>
      <Typography variant="h4" gutterBottom>
        Mediciones Corporales
      </Typography>
      {measurements
        .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
        .map((measurement) => (
          <Accordion key={measurement.id}>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography>
                {new Date(measurement.date).toLocaleString([], {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                })}
              </Typography>
            </AccordionSummary>
            <AccordionDetails>
  <Grid container spacing={2}>
    <Grid item xs={12} sm={6}>
      <Typography variant="subtitle1"><strong>Peso:</strong> {measurement.weight} kg</Typography>
      <Typography variant="subtitle1"><strong>Altura:</strong> {measurement.height} cm</Typography>
      <Typography variant="subtitle1"><strong>Porcentaje de Grasa Corporal:</strong> {measurement.bodyFatPercentage} %</Typography>
      <Typography variant="subtitle1"><strong>IMC:</strong> {measurement.bmi}</Typography>
      <Typography variant="subtitle1"><strong>Pliegue Tríceps:</strong> {measurement.tricepFold} mm</Typography>
      <Typography variant="subtitle1"><strong>Pliegue Subescapular:</strong> {measurement.subscapularFold} mm</Typography>
      <Typography variant="subtitle1"><strong>Pliegue Biceps:</strong> {measurement.bicepFold} mm</Typography>
    </Grid>
    <Grid item xs={12} sm={6}>
      <Typography variant="subtitle1"><strong>Circunferencia Pantorrilla:</strong> {measurement.calf} cm</Typography>
      <Typography variant="subtitle1"><strong>Brazo Relajado:</strong> {measurement.relaxedArm} cm</Typography>
      <Typography variant="subtitle1"><strong>Brazo Flexionado:</strong> {measurement.flexedArm} cm</Typography>
      <Typography variant="subtitle1"><strong>Caderas:</strong> {measurement.hips} cm</Typography>
      <Typography variant="subtitle1"><strong>Masa Grasa:</strong> {measurement.fatMass} kg</Typography>
      <Typography variant="subtitle1"><strong>Masa Magra:</strong> {measurement.leanMass} kg</Typography>
      <Typography variant="subtitle1"><strong>Masa Muscular:</strong> {measurement.muscleMass} kg</Typography>
    </Grid>
    <Grid item xs={12}>
      <Typography variant="subtitle1"><strong>Recomendaciones del Entrenador:</strong> {measurement.trainerRecommendations || 'N/A'}</Typography>
    </Grid>
  </Grid>
</AccordionDetails>

          </Accordion>
        ))}
    </Box>
  );
};

export default MeasurementsPage;
// src/pages/UserDashboard/TrainerCalendarPage.tsx

import React from 'react';
import TrainerCalendar from '../../components/Trainer-Calendar/TrainerCalendar';

const TrainerCalendarPage: React.FC = () => {
  return (
    <div>
      <TrainerCalendar />
    </div>
  );
};

export default TrainerCalendarPage;
import React, { useEffect, useState } from 'react';
import { Typography, Box, Paper, Grid, Table, TableHead, TableBody, TableCell, TableRow, TableContainer } from '@mui/material';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import apiClient from '../../Apis/apiConfig';

interface Subscription {
  id: number;
  plan?: {
    id: number;
    name: string;
    price: number;
  };
  startDate: string;
  endDate: string;
  active: boolean;
}

interface TrainerSubscription {
  id: number;
  startDate: string;
  endDate: string;
  active: boolean;
  personalTrainer: {
    id: number;
    specialization: string;
    monthlyFee: number;
    user: {
      username: string;
      email: string;
      profileImageUrl?: string | null;
    };
  };
}

interface PaymentDTO {
  id: number;
  planName: string;
  paymentType: string;
  paymentDate?: string;
  paymentMethod: string;
  transactionAmount: number;
  products?: {
    name: string;
    price: number;
    brand?: string;
    paymentMethod?: string;
  }[];
}

interface DashboardData {
  planSubscriptions: Subscription[];
  payments: PaymentDTO[];
  trainerSubscriptions: TrainerSubscription[];
}

export const UserDashboard: React.FC = () => {
  const { token } = useSelector((state: RootState) => state.auth);
  const [data, setData] = useState<DashboardData | null>(null);

  useEffect(() => {
    const fetchDashboardData = async () => {
      if (!token) return;
      try {
        const config = {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        };
        const response = await apiClient.get('/users/dashboard', config);
        setData(response.data);
      } catch (error) {
        console.error('Error fetching dashboard data:', error);
      }
    };
    fetchDashboardData();
  }, [token]);

  const planPayments = (data?.payments ?? []).filter(pay => pay.paymentType === 'plan');
  const productPayments = (data?.payments ?? []).filter(pay => pay.paymentType === 'producto');

  return (
    <Box sx={{ padding: 4 }}>
      <Typography variant="h4" gutterBottom>
        Bienvenido al Dashboard de Usuario
      </Typography>

      {data && (
        <>
          <Grid container spacing={3} sx={{ mt: 4 }}>
            {/* Suscripciones al Plan */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ padding: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>
                  Suscripciones al Plan
                </Typography>
                {data.planSubscriptions.length === 0 ? (
                  <Typography>No tienes suscripciones a planes actualmente.</Typography>
                ) : (
                  data.planSubscriptions.map((sub) => (
                    <Box key={sub.id} sx={{ mb: 2 }}>
                      <Typography variant="subtitle1">
                        Plan: {sub.plan?.name}
                      </Typography>
                      <Typography>
                        Precio: ${sub.plan?.price}
                      </Typography>
                      <Typography>
                        Inicio: {sub.startDate}
                      </Typography>
                      <Typography>
                        Fin: {sub.endDate}
                      </Typography>
                      {/* Aplica el estilo condicional */}
                      <Typography sx={{ color: sub.active ? 'green' : 'red' }}>
                        {sub.active ? 'Vigente' : 'Terminado'}
                      </Typography>
                    </Box>
                  ))
                )}
              </Paper>
            </Grid>

            {/* Suscripciones al Entrenador */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ padding: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>
                  Suscripciones al Entrenador
                </Typography>
                {data.trainerSubscriptions.length === 0 ? (
                  <Typography>No tienes suscripciones a entrenadores actualmente.</Typography>
                ) : (
                  data.trainerSubscriptions.map((tsub) => (
                    <Box key={tsub.id} sx={{ mb: 2 }}>
                      <Typography variant="subtitle1">
                        Entrenador: {tsub.personalTrainer.user.username}
                      </Typography>
                      <Typography>
                        Especialidad: {tsub.personalTrainer.specialization}
                      </Typography>
                      <Typography>
                        Mensualidad: ${tsub.personalTrainer.monthlyFee}
                      </Typography>
                      <Typography>
                        Inicio: {tsub.startDate}
                      </Typography>
                      <Typography>
                        Fin: {tsub.endDate}
                      </Typography>
                      <Typography sx={{ color: tsub.active ? 'green' : 'red' }}>
                        {tsub.active ? 'Vigente' : 'Terminado'}
                      </Typography>
                    </Box>
                  ))
                )}
              </Paper>
            </Grid>

            {/* Pagos de Plan */}
            <Grid item xs={12} md={4}>
              <Paper sx={{ padding: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>
                  Pagos de Plan
                </Typography>
                {planPayments.length === 0 ? (
                  <Typography>No tienes pagos de plan registrados actualmente.</Typography>
                ) : (
                  planPayments.map((pay) => (
                    <Box key={pay.id} sx={{ mb: 2 }}>
                      <Typography>Plan: {pay.planName}</Typography>
                      <Typography>Método de pago: {pay.paymentMethod}</Typography>
                      <Typography>Monto: ${pay.transactionAmount}</Typography>
                      <Typography>
                        Fecha de pago: {new Date(pay.paymentDate!).toLocaleString()}
                      </Typography>
                    </Box>
                  ))
                )}
              </Paper>
            </Grid>
          </Grid>

          {/* Tabla de Productos */}
          <Box sx={{ mt: 4 }}>
            <Typography variant="h6" gutterBottom>
              Productos Adquiridos
            </Typography>
            {productPayments.length === 0 ? (
              <Typography>No tienes productos adquiridos actualmente.</Typography>
            ) : (
              <TableContainer component={Paper}>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Nombre</TableCell>
                      <TableCell>Precio</TableCell>
                      <TableCell>Marca</TableCell>
                      <TableCell>Método de Pago</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {productPayments.flatMap((pay) =>
                      pay.products?.map((prod, idx) => (
                        <TableRow key={`${pay.id}-${idx}`}>
                          <TableCell>{prod.name}</TableCell>
                          <TableCell>${prod.price}</TableCell>
                          <TableCell>{prod.brand}</TableCell>
                          <TableCell>{prod.paymentMethod}</TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              </TableContainer>
            )}
          </Box>
        </>
      )}
    </Box>
  );
};
import React, { useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';

interface PaymentDetails {
  paymentId: string | null;
  status: string | null;
  externalReference: string | null;
}

const PaymentFailurePage = () => {
  const location = useLocation();
  const [paymentDetails, setPaymentDetails] = useState<PaymentDetails | null>(null);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const paymentId = params.get('payment_id');
    const status = params.get('status');
    const externalReference = params.get('external_reference');

    setPaymentDetails({
      paymentId,
      status,
      externalReference,
    });
  }, [location]);

  return (
    <div>
      <h1>¡Pago Fallido!</h1>
      {paymentDetails && (
        <div>
          <p>ID de Pago: {paymentDetails.paymentId}</p>
          <p>Estado: {paymentDetails.status}</p>
          <p>Referencia Externa: {paymentDetails.externalReference}</p>
          <p>Lo sentimos, tu transacción no se pudo completar.</p>
          {/* Aquí podrías mostrar opciones para reintentar el pago, ir al carrito, etc. */}
        </div>
      )}
    </div>
  );
};

export default PaymentFailurePage;
import React, { useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';
import apiClient from '../../../Apis/apiConfig';
import './PaymentReceipt.css'; // Crear este archivo CSS

// Estructura para almacenar los detalles recibidos de /payment/details
interface PaymentDTO {
  id: number;
  userId: number;
  username: string;
  paymentType: string;
  status: string | null;
  paymentMethod: string | null;
  transactionAmount: number;
  paymentDate: string;  // o Date si lo parseas
  planName?: string;
  subscriptionStartDate?: string; // o Date
  subscriptionEndDate?: string;   // o Date
  products?: ProductDto[];
}

interface ProductDto {
  name: string;
  price: number;
  description: string;
  brand: string;
  flavor: string;
  imageUrl: string;
  // quantity?: number; // si quisieras mostrar cuántos compró
}

const PaymentSuccessPage = () => {
  const location = useLocation();
  const [paymentData, setPaymentData] = useState<PaymentDTO | null>(null);

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const paymentId = params.get('payment_id');  
  
    if (paymentId) {
      apiClient
        .get<PaymentDTO>(`/payment/details/mp/${paymentId}`)
        .then((response) => { 
          setPaymentData(response.data); 
        })
        .catch((error) => {
          console.error('Error al obtener detalles de pago:', error);
        });
    }
  }, [location]);
  
  const handlePrint = () => {
    window.print();
  };

  if (!paymentData) return <div>Cargando comprobante...</div>;
  return (
    <div className="receipt-container">
      <button onClick={handlePrint} className="print-button">
        Imprimir Comprobante
      </button>

      <div className="receipt">
        <header className="receipt-header">
          <h1>Comprobante de Pago</h1>
          <div className="company-info">
            <h2>Mi Empresa S.A.C.</h2>
            <p>RUC: 12345678901</p>
            <p>Av. Ejemplo 123, Lima, Perú</p>
            <p>Teléfono: (01) 234-5678</p>
          </div>
        </header>

        <div className="receipt-details">
          <div className="detail-row">
            <span>Fecha:</span>
            <span>{new Date(paymentData.paymentDate).toLocaleDateString()}</span>
          </div>
          <div className="detail-row">
            <span>N° Comprobante:</span>
            <span>{paymentData.id}</span>
          </div>
          <div className="detail-row">
            <span>Cliente:</span>
            <span>{paymentData.username}</span>
          </div>
          <div className="detail-row">
            <span>Método de Pago:</span>
            <span>{paymentData.paymentMethod}</span>
          </div>
          <div className="detail-row">
            <span>Estado:</span>
            <span className="status-success">{paymentData.status}</span>
          </div>
        </div>

        {paymentData.planName && (
          <div className="plan-section">
            <h3>Suscripción al Plan</h3>
            <div className="plan-details">
              <p><strong>Plan:</strong> {paymentData.planName}</p>
              <p><strong>Duración:</strong> Del {paymentData.subscriptionStartDate} al {paymentData.subscriptionEndDate}</p>
            </div>
          </div>
        )}

        {paymentData.products && paymentData.products.length > 0 && (
          <div className="products-section">
            <h3>Productos Adquiridos</h3>
            <table className="products-table">
              <thead>
                <tr>
                  <th>Producto</th>
                  <th>Descripción</th>
                  <th>Precio</th>
                </tr>
              </thead>
              <tbody>
                {paymentData.products.map((prod, idx) => (
                  <tr key={idx}>
                    <td>{prod.name}</td>
                    <td>{prod.description} - {prod.brand} ({prod.flavor})</td>
                    <td>S/ {prod.price.toFixed(2)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}

        <div className="total-section">
          <div className="total-row">
            <span>TOTAL PAGADO:</span>
            <span>S/ {paymentData.transactionAmount.toFixed(2)}</span>
          </div>
        </div>

        <footer className="receipt-footer">
          <p>¡Gracias por su compra!</p>
          <p>Para consultas o devoluciones, contactar a: soporte@miempresa.com</p>
          <p>Este comprobante es válido como factura electrónica</p>
        </footer>
      </div>
    </div>
  );
};

export default PaymentSuccessPage;
.receipt-container {
    max-width: 800px;
    margin: 2rem auto;
    padding: 20px;
  }
  
  .print-button {
    background: #007bff;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 20px;
  }
  
  .print-button:hover {
    background: #0056b3;
  }
  
  .receipt {
    border: 2px solid #000;
    padding: 30px;
    background: #fff;
    font-family: 'Courier New', monospace;
  }
  
  .receipt-header {
    text-align: center;
    border-bottom: 2px dashed #000;
    margin-bottom: 20px;
    padding-bottom: 20px;
  }
  
  .company-info h2 {
    margin: 5px 0;
    font-size: 1.5em;
  }
  
  .company-info p {
    margin: 3px 0;
    font-size: 0.9em;
  }
  
  .receipt-details {
    margin: 20px 0;
  }
  
  .detail-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    padding: 5px 0;
    border-bottom: 1px dashed #ddd;
  }
  
  .status-success {
    color: #28a745;
    font-weight: bold;
  }
  
  .products-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
  }
  
  .products-table th,
  .products-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  
  .products-table th {
    background-color: #f8f9fa;
  }
  
  .total-section {
    margin-top: 20px;
    border-top: 2px solid #000;
    padding-top: 15px;
  }
  
  .total-row {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.1em;
  }
  
  .receipt-footer {
    text-align: center;
    margin-top: 30px;
    padding-top: 15px;
    border-top: 2px dashed #000;
    font-size: 0.9em;
  }
  
  @media print {
    .print-button {
      display: none;
    }
    
    .receipt {
      border: none;
      padding: 0;
    }
    
    body {
      background: #fff !important;
      margin: 0;
      padding: 20px;
    }
  }// src/api/groupClassService.ts

import apiClient from '../../Apis/apiConfig';
import { GroupClass } from '../interfaces/GroupClass';



export const getAvailableGroupClasses = async (): Promise<GroupClass[]> => {
  const response = await apiClient.get('/group-classes/available');
  return response.data;
};

export const bookGroupClass = async (classId: number) => {
  const response = await apiClient.post(`/group-classes/${classId}/book`);
  return response.data;
};

// Ya teníamos createGroupClass y assignTrainerToClass, las dejamos como están.
// src/services/measurementService.ts

import apiClient from '../../Apis/apiConfig';
import { BodyMeasurement } from '../../Trainers/services/trainerClientService';


const getMeasurements = (clientId: number) => {
  console.log("id cient",clientId);
  return apiClient.get<BodyMeasurement[]>(`/clients/${clientId}/measurements`);
};

export default {
  getMeasurements,
};
